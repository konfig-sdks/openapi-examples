openapi: 3.0.2
info:
  title: Miso API
  description: >

    # Overview

    Miso’s approach to personalization is to train machine learning Engines on
    three core data sets:


    1. Your site’s log of historical and real-time interactions,

    2. Your catalog of products and content, and

    3. Your users. Miso provides the output of its Engines to you, so you can
    build search and recommendation

    experiences that are personalized down to the individual level (n=1
    personalization).


    To see how Miso works and explore the power of its Engines, we recommend
    following

    [this tutorial](https://docs.askmiso.com/) to get

    started with our Playground data. Integrating your site or application with
    Miso happens in three basic steps:


    1. Upload your data

    2. Train your Engines

    3. Build search and recommendation experiences with the output of your
    Engines.



    Miso provides two main integration points. The first is your [Dojo
    Dashboard](https://dojo.askmiso.com/),

    which is used to set up your Engines with the conversions you want to
    optimize and your training schedule.

    Dojo is also a great way to get familiar with Miso by manually uploading
    data and exploring the output of

    Miso’s Engines. In Dojo’s Sandboxes, you can tweak your Engine settings and
    see visual examples of Miso’s search

    and recommendations running on your live data.


    The second integration point is Miso’s API, which lets you automatically
    manage your data in Miso and build

    experiences that leverage the output of Miso’s personalization Engines.



    Miso’s API is composed of two major groups of REST API endpoints: Data APIs
    and Engine APIs.


    ### Data APIs

    Data APIs collect input to Miso's personalization Engines. These APIs all
    support high-throughput

    data ingestion through bulk insert, and satisfy GDPR and CCPA compliance by
    letting users delete their data

    from Miso. Subcategories of Data APIs are:


    * [Interaction APIs](https://api.askmiso.com), for managing your Interaction
    records. By uploading historical and real-time Interaction

    records, you tell Miso how users are engaging with the products and content
    on your site, and in turn, Miso’s

    Engines learn how to optimize your conversion funnels.

    * [Product / Content APIs](https://api.askmiso.com), for managing your
    Product / Content records. These records provide a deep semantic

    understanding of your catalog and keep Miso up to date about your offerings
    so it can make smart and timely

    suggestions. The `product_id` is how Miso links Product / Content records to
    your Interaction records.

    * [User APIs](https://api.askmiso.com), for managing your User records.
    These records tell Miso about your site’s users and visitors,

    so Miso can build an understanding of user segmentation and behavior in
    relation to products and content.

    The `user_id` is how Miso links User records to your Interaction records.


    As a rule of thumb, we recommend batching up data to avoid timeout risks.
    For the Product / Content and User

    Upload APIs, we recommend limiting each API upload call to about 100 records
    at a time. For the Interaction

    Upload API, we recommend limiting your calls to around 10,000 records at a
    time.


    ### Engine APIs

    Engine APIs provide the output of Miso's personalization Engines. We
    designed these APIs with a focus on low

    latency and high availability. Most of these APIs' 95th percentile response
    time is under 75ms,

    and the services are replicated to at least three separate instances for
    high availability.

    The types of Engine APIs are:


    * [Search APIs](https://api.askmiso.com), for getting Miso’s personalized
    search results for a user, with search-as-you-type and

    autocompletion.

    * [Recommendation APIs](https://api.askmiso.com), for retrieving Miso’s
    recommendations that match users with

    the products, categories, and product attributes that are likely to drive
    conversions.


    # Authentication

    [View your API Keys in your Dojo
    Dashboard.](https://dojo.askmiso.com/docs/api-browser)


    There are three environments in Miso:

    * **Playground**, a read-only tutorial environment with sample data.

    * **Development**, for staging, QA, and experimentation.

    * **Production**, where you run your live integration with Miso.


    Access a Miso environment by passing in the corresponding API key in your
    API calls. There is one publishable

    key and one secret key per environment.


    API Key can passed with query parameter `api_key`, or using the `X-API-KEY`
    header.
  version: 1.1.4
  x-konfig-ignore:
    potential-incorrect-type: true
servers:
  - url: https://api.askmiso.com
tags:
  - description: >+

      Miso's Product / Content APIs let you upload, read, and delete Product /
      Content records that represent your site's

      catalog.


      ### Product / Content records

      Miso analyzes your Product / Content records to provide personalized
      search and recommendations that connect users

      with products or content on your site or application.


      Much of Miso's search and personalization capability relies on
      understanding your catalog in-depth and drawing

      correlations between your catalog and your users' consumption or
      purchasing behaviors. In other words, Miso

      discovers that, with high correlation, users who are interested in certain
      product attributes would also be

      interested in other products with similar or related attributes. (For
      simplicity, we will often overload the word

      "products" to mean items for purchase if you are an eCommerce business,
      and content to consume if you are a content

      marketplace.)


      To fully optimize your search and recommendations, it is important to
      provide Miso with Product / Content records

      that are complete and accurate. We define a set of common attributes that
      capture the basics of most eCommerce and

      content media products, such as `title`, `description`, `categories`,
      `tags`, `material`, `authors`, etc.


      If your products' characteristics cannot be fully captured by these
      fields, we recommend that you specify

      `custom_attributes`. For Miso, the more complete the product information
      is, the better its personalized search

      and recommendations become.

    name: Product / Content APIs
  - name: Recommendation APIs
  - description: >+

      Miso’s User APIs let you upload, read, and delete User records that tell
      Miso about your site’s unique users and

      visitors.


      ### User records

      User records specify relatively static attributes for a given user, such
      as their `age`, `gender`, `city`, etc. As a

      rule of thumb, you should put information here that is not already
      captured in your

      [Interaction records](https://api.askmiso.com). For example,
      *last_bought_product* is probably not needed here because

      Miso already can tell that from the [Interaction
      records](https://api.askmiso.com).


      Miso will discover the correlations between a user's attributes and their
      behaviors on your site. For example, Miso

      might determine that users of a certain age group tend to be interested in
      certain products or a certain price

      range. These insights will be taken into account when predicting users'
      interests, in particular for new users who

      have not yet generated many interaction records.


      We define a set of common user attributes for e-Commerce and content media
      sites. Some of them, such as `name` are

      for display in the Dojo dashboard only. The rest are for model quality.
      Most attributes are optional and you don't

      need to specify them if you don't collect such data. On the other hand,
      you can specify your custom user attributes

      in the `custom_attributes` field. Miso will analyze custom user attributes
      to improve the model quality as well.

    name: User APIs
  - name: Search APIs
  - name: Q&A APIs
  - description: >+

      Miso’s Interaction APIs let you manage your Interaction records stored
      with Miso.


      ### Interaction records

      Your Interaction records tell Miso about user interactions with products
      and content on your site or application.

      From these interactions, Miso understands how users move through your
      conversion funnels: which products or content

      assets attract the attention of each individual user, and which products
      or content ultimately will be purchased or

      consumed by each of them. With these insights, Miso makes real-time
      tailored recommendations for each user, and

      responds to each of their clicks and views on the site (even for anonymous
      users).


      Interaction records share some common attributes, but are distinguished by
      their type.

      Miso captures 23 different interaction types, divided into the following 6
      groups:


      #### Core click-streams

      * `product_detail_page_view`: a user viewed the detail page for a product

      * `search`: a user made a search request with keywords and (optionally)
      filters


      The above interactions are the core fuel for Miso's personalization
      Engines, because they happen in a much higher

      frequency than other interactions and provide an unbiased and
      high-fidelity view of users' interests on the site.

      The collection of these interactions is highly important for Miso's
      personalization performance. At the minimum,

      you should implement the `product_detail_page_view` interaction to start
      with.


      #### Conversion (eCommerce)

      * `add_to_cart`: a user added a product to the shopping cart

      * `remove_from_cart`: a user removed a product from the shopping cart

      * `checkout`: a user checked out and started the payment process

      * `refund`: a user refunded the product

      * `subscribe`: a user subscribed to a product


      The above interactions are the main revenue drivers for eCommerce sites.
      It’s important to collect them so that

      Miso can not only drive click-through rates, but actually improve the
      revenue in a targeted way. To start with,

      you should at least implement the `add_to_cart` interaction.


      #### Consumption (content media)

      * `read`, `watch`, and `listen` interactions capture how and for how long
      a user consumed a piece of content.

      * `add_to_collection`: a user added an product to their personal
      collection

      * `remove_from_collection`: a user removed an product from their personal
      collection


      If you are a content site, the above interactions are the main drivers to
      users' satisfaction on the site.

      Collecting these interactions allows Miso to drive consumption rates and
      consumption durations for the content on

      your site. If you run a content site, you should implement at least one of
      these interactions.


      #### Feedback signals

      * `like`, `dislike`, `share`, `rate`,  and `bookmark` are common ways 
      users express their interests.


      These are strong signals for Miso to understand each user's preferences
      regarding your products or content. You

      should send these signals to Miso if you have any of these UI patterns on
      your site.


      #### Performance Checking

      * `impression`: a user saw or was presented with a product or content
      asset (but didn't yet interact with it)

      * `viewable_impression`: the product or content presented is actually
      viewed by the user
        (for example, minimum of 50% of the pixels were in viewable space for at least one continuous second.)
      * `click`: a user clicked on something (for example, a product item)


      #### Additional click-streams

      * `home_page_view`: user viewed your home page

      * `category_page_view`: a user viewed the page for a specific “group” or
      “family” or products or content in your catalog

      * `promo_page_view`: user viewed the promotion pages about certain
      products

      * `product_image_view`: user clicked on or otherwise interacted with  the
      product image (e.g. enlarged the image)


      The above interactions are additional signals for Miso to understand
      users' behavior on the site.


      #### Custom

      * `custom` interaction types are reserved for you to define your own
      business-specific interaction types.


      Miso will analyze any custom interactions you define to infer users'
      interests and preferences.


    name: Interaction APIs
  - description: >+

      Miso's new Ask API is the next generation of question answering APIs.

      It is designed to provide accurate and concise answers to your questions

      based on your existing product documents.


      Ask API offers a seamless and effective way to address complex queries in

      a near-realtime fasion.


      Miso preprocesses your product documents, breaking them into segments.

      When a question is received, Miso finds the most related product and
      segments, then

      summarize to a concise and informative answer based on the identified
      segments,

      including products related to the question.


      Possible use case includes: knowledge base, documentation search, customer
      support, and more.


      To use the Ask API, you first submit a "question" you want to ask.

      Question can be any human-readable text. Then a question ID will returned,

      and the question will be processed in the background.


      After receving question ID, you can then use the question ID to get latest
      answer

      to the question as it is being compiled.


      ----


      For example:


      If you want to know about the inner workings of nginx:


      ```json

      {
          "question":"How nginx works internally?"
      }

      ```


      The API would response with a question id.

      ```json

      {
          "data": {
              "question_id": "ff4775fa-345e-4d28-91b0-8fb8bf095e6a"
          },
          "message": "success"
      }

      ```


      Then you can send a GET request to
      `/v1/ask/questions/{question_id}/answer`

      to get the latest answer as it is being compiled and summerized.

      You can use `answer_stage` and `finished` to check current answer status.


      Here's the response of answer API when data is fetched and being verified,
      before answer is summerized:

      ```json

      {
          "message": "success",
          "data": {
              "question": "How nginx works internally?",
              "question_id": "ff4775fa-345e-4d28-91b0-8fb8bf095e6a",
              "parent_question_id": null,
              "answer_stage": "Verifying possible answers",
              "finished": false,
              "answer": "Verifying possible answers ...",
              "sources": [],
              "related_resources": [],
              "followup_questions": []
          }
      }

      ```


      Here's the response when answer is fullly summerized:


      ```json

      {
          "message": "success",
          "data": {
              "question": "How nginx works internally?",
              "question_id": "ff4775fa-345e-4d28-91b0-8fb8bf095e6a",
              "parent_question_id": null,
              "answer_stage": "Generating summary",
              "finished": true,
              "answer": "# How does Nginx work internally?\n\n## Internal requests [1]\n\nNginx differentiates between external and internal requests. External requests...[omitted for simplicity]",
              "sources": [
                  {
                      "title": "Internal requests",
                      "product_id": "9781788623551",
                      "child_title": "Internal requests",
                      "child_id": "203",
                      "snippet": "<mark>Internal requests\nNginx differentiates external and internal requests.</mark>"
                  },
                  {
                      "title": "5. Nginx Core Architecture",
                      "product_id": "9781484216569",
                      "child_title": "5. Nginx Core Architecture",
                      "child_id": "5",
                      "snippet": "Checks if the client can access of the requested the resource.\n<mark>It is at this step that Nginx...[omitted]</mark>"
                  },
                  {
                      "title": "2. Managing Nginx",
                      "product_id": "9781785289538",
                      "child_title": "2. Managing Nginx",
                      "child_id": "14",
                      "snippet": "<mark>The Nginx connection processing architecture\nBefore you study...[omitted]</mark>"
                  },
                  {
                      "title": "3. Nginx Core Directives",
                      "product_id": "9781484216569",
                      "child_title": "3. Nginx Core Directives",
                      "child_id": "3",
                      "snippet": "<mark>Understanding the Default Configuration\nThe default configuration...[omitted]</mark>"
                  },
                  {
                      "title": "4. Nginx Modules",
                      "product_id": "9781484216569",
                      "child_title": "4. Nginx Modules",
                      "child_id": "4",
                      "snippet": "<mark>Based on the context like HTTP, MAIL, and STREAM, it creates a ...[omitted]</mark>"
                  }
              ],
              "related_resources": [],
              "followup_questions": [
                  "What are the steps involved in processing a request and generating a response in Nginx?",
                  "How do Nginx modules contribute to the internal workings of Nginx?"
              ]
          }
      }

      ```


      Related product IDs will be returned along with human-readable answer.
      Related text section in the product will also be quoted.


      If a product has any children, they will also be matched, `child_id` and
      `child_title` will be included for sources belonging to the product's
      children.


      You can use `fq` to limit the search scope, for example, to a specific
      product type or other condition.


      If you only want to search for books (no articles of videos), you can use
      `fq=type:book` like this:

      ```json

      {
          "question":"How nginx works internally?"
          "fq": "type:book"
      }

      ```


      If you want the answer to contain any other fields, set `source_fl` when
      submitting the question.

    name: Ask APIs
  - description: >

      Miso's experiment APIs let you do the A/B testing of your current result
      with Miso.


      ### Start an experiment in Dojo.


      Login to the [dojo](https://dojo.askmiso.com) platform.

      Create an experiment event for you.


      ### Start running A/B testing in your environment.


      #### Implement A/B testing code.


      Here's an example in NodeJS. You can also use any programming language of
      you choice.

      ```nodejs

      const axios = require('axios');


      async function get_user_experiment_info(api_key, experiment_id, user_id) {
          data = {"user_id": user_id}
          endpoint = `https://api.askmiso.com/v1/experiments/${experiment_id}/events?api_key=${api_key}`
          return await axios.post(endpoint, data)
      }


      const api_key = '<YOUR_SECRET_API_KEY>'

      const experiment_id = "<EXPERIMENT_ID | EXPERIMENT_SLUG_NAME>"

      let user_id = 'user_1234'  // use to evaluate a treatment for


      const user_experiment_info = get_user_experiment_info(api_key,
      experiment_id, user_id)

      user_experiment_info.then((response) => {
          let variant = response.data['variant']
          if (variant['name'] == "treatment") {
              // insert code here to show "treatment" variant
          } else if (variant['name'] == "control") {
              // insert code here to show "control" variant
          } else {
              // unexpected variant name. raise error
              throw new Error(`Unexpected variant name ${variant["name"]}`)
          }
      })

      ```


      If you implement A/B testing code in FrontEnd, like JavaScript, and are
      also worried about exploding the secret api_key. You can choose to use
      anonymous_id with the public_api_key for this API. Here's an example.


      ```javascript

      const apiKey = '<YOUR_PUBLIC_API_KEY>';

      const experimentId = '<EXPERIMENT_ID | EXPERIMENT_SLUG_NAME>';

      const anonymous_id = 'user_1234';  // use to evaluate a treatment for


      function getUserExperimentInfo(apiKey, experimentId, anonymous_id) {
        const data = {
          user_id: anonymous_id
        };
        const url = `https://api.askmiso.com/v1/experiments/${experimentId}/events?api_key=${apiKey}`;
        const options = {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data),
        };

        return window.fetch(url, options)
          .then((response) => response.json())
          .then((data) => {
            const variantName = data.variant.name;
            if (variantName === `${this.treatmentName}`) {
              // insert code here to show 'treatment' variant
            } else if (variantName === `${this.controlName}`) {
              // insert code here to show 'control' variant
            } else {
              // unexpected variant name, throw error
              throw new Error(`Unexpected variant name: ${variantName}`);
            }
          })
          .catch((error) => console.error(error));
      }


      getUserExperimentInfo(apiKey, experimentId, anonymous_id);

      ```
    name: Experiment APIs
  - description: >

      The Bulk API provides an efficient interface for making multiple Search /
      Recommendations / Q&A requests in one API

      call. These requests will be executed concurrently at the Miso side, and
      returned at once when all of them are finished.

      This API is particularly useful when you need to invoke multiple Miso APIs
      to respond to a user request.

      Using this API, you can batch multiple API calls into one, and
      significantly save the network round-trip times.


      ### Request schema

      The request schema for this API call is as follow:

      ```

      POST /v1/bulk

      {
        "requests": [
          {
            "api_name": "search/search",
            "body": { ... }
          },
          {
            "api_name": "recommendation/product_to_product",
            "body": { ... }
          },
          ...
        ]
      }

      ```

      Each request object should contain:

      * **api_name**: name of the API you want to access. The name should
      contain a slash `/`.

      For example, search/search for search requests, search/autocomplete for
      autocomplete requests, etc.

      * **body**: the complete request body as if you are making the API request
      individually.


      Any errors in one of the requests will be returned, and will not prevent
      other requests from being

      executed.


      ### Response Schema

      Bulk API endpoint will return the API responses in the same order as they
      appear in the request.

      For example, if the Bulk API request is like the following:

      ```

      POST /v1/bulk

      {
        "requests": [
          {... request 1 ...},
          {... request 2 ...}
        ]
      }

      ``` 


      The response will be like:

      ```

      {
        "data": [
          // response for request 1
          {
            "error": false,
            "status_code": 200,
            "body": { ... }
          },
          // response for request 2
          {
            "error": false,
            "status_code": 200,
            "body": { ... }
          }
        ]
      }

      ```


      Each response object will contain the following fields:

      * **error**: whether there was an error with the request. You should check
      this field to determine whether to

      perform error handling.

      * **status_code**: status code of the request.

      * **body**: the response body of the request (as if the request was sent
      individually).


      Let's see a complete example with MovieLens data. The following requests
      will issue two requests in one API call that 

      return the `Sci-Fi` movies directed by

      *Ridley Scott*, and *James Cameron* respectively in the first and second
      responses:

      ```

      POST /v1/bulk

      {
        "requests": [
          {
            "api_name": "search/search",
            "body": {
              "user_id": "test_user",
              "q": "sci-fi",
              "fq": "custom_attributes.director:\"Ridley Scott\""
            }
          },
          {
            "api_name": "search/search",
            "body": {
              "user_id": "test_user",
              "q": "sci-fi",
              "fq": "custom_attributes.director:\"James Cameron\""
            }
          }
        ]
      }

      ```

      The response will be like:

      ```

      {
        "data": [
          {
            "error": false,
            "status_code": 200,
            "body": {
              "data": {
                "took": 136,
                "miso_id": "19ab254c-5fb8-11ec-bd48-b20169940af9",
                "products": [
                  {
                    "product_id": "blade-runner",
                    "title": "Blade Runner (1982)"
                  }
                ],
                "total": 6,
                "start": 0
              }
            }
          },
          {
            "error": false,
            "status_code": 200,
            "body": {
              "data": {
                "took": 116,
                "miso_id": "19ab254c-5fb8-11ec-bd48-b20169940af9",
                "products": [
                  {
                    "product_id": "avatar",
                    "title": "Avatar (2009)"
                  }
                ],
                "total": 10,
                "start": 0
              }
            }
          }
        ]
      }

      ```
    name: Bulk API
paths:
  /v1/experiments/{experiment_id_or_slug}/events:
    post:
      tags:
        - Experiment APIs
      summary: Send Experiment Event
      operationId: ExperimentApIs_sendEvent
      security:
        - Secret API Key: []
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ExperimentRequest'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SendExperimentResponse'
        '401':
          description: Unauthorized
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ExperimentApIsSendEventResponse'
        '404':
          description: Not Found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ExperimentApIsSendEvent404Response'
        '422':
          description: Unprocessable Entity
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ExperimentApIsSendEvent422Response'
  /v1/interactions:
    post:
      tags:
        - Interaction APIs
      summary: Interaction Upload API
      operationId: InteractionApIs_insertRecords
      security:
        - Secret API Key: []
        - Publishable API Key: []
      description: >-
        Bulk API to insert Interaction records. This endpoint accepts POST
        requests with JSON data  containing an array of

        Interaction records wrapped in a dictionary:


        ```

        POST /v1/interactions


        {"data": [interaction_1, interaction_2, interaction_3]}

        ```


        For real-time tracking, we recommend sending the interaction records to
        this API as soon as the interactions take

        place. This API is also ideal for bulk-inserting historical records that
        your site collected before using Miso.
         Miso can analyze the historical records and provide personalization for your users from the get-go. We recommend
         limiting your calls to around 10,000 records at a time to avoid memory issues or timeout risks.

        ###  Anonymous users

        For users who did not sign in, we can still make recommendations for
        them by tracking their `anonymous_id`, which is a pseudo-unique
        substitute for the `user_id`. The personalization and search APIs all
        accept `anonymous_id` in the place of `user_id` to return tailored
        results for anonymous users.


        When an anonymous user later signs in and the `user_id` and
        `anonymous_id` are both present, the `anonymous_id` will be linked to
        the `user_id` along with the past interactions associated with it.


        The typical mechanism to generate an `anonymous_id` is to use cookies or
        the browser localStorage. However, if you don't collect such information
        in your historical records, a hash of the IP address, optionally
        combined with the User-Agent string, is also a reasonable substitute for
        `anonymous_id`, and is most likely collected by your web server logs
        already.


        ### Schema validation

        The Interaction Upload API will validate the inserted records against
        the API schema.

        Any schema errors will cause the whole request to fail, and none of the
        records will be inserted (`status_code=422`).

        You should check the `response.errors` field to see if there are any
        errors.


        For example, the response below means there are no errors
        (`status_code=200`):

        ```javascript

        {
            "message": "success"
        }

        ```


        Any schema error will cause the whole request to fail: the API will
        return `status_code=422`, and none of the

        records will be inserted. You should check `data` field in the response
        to see where the errors are located. For

        example, the response below means there are schema errors in the
        interaction record at index 0:

        ```javascript

        {
            "errors": true, // there are errors. please check!
            "message": "None of the records were inserted because at least one of them contained schema errors. Please see the `data` field for details.",
            "data": [
                "data.0.product_ids is invalid. The attribute was expected to be of type ''array', 'null'' but type 'string' was given.",
                "data.0.timestamp is invalid. The attribute should match the 'date-time' format."
            ]
        }

        ```
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/InteractionBulkIn'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InteractionCreateOut'
        '401':
          description: Unauthorized
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InteractionApIsInsertRecordsResponse'
        '403':
          description: Forbidden
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InteractionApIsInsertRecords403Response'
        '422':
          description: Unprocessable Entity
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InteractionApIsInsertRecords422Response'
    delete:
      tags:
        - Interaction APIs
      summary: Interaction Delete API
      operationId: InteractionApIs_removeData
      security:
        - Secret API Key: []
      description: >-
        The endpoint will delete users' interaction data entirely from the log
        of interactions you have uploaded to Miso.

        This API enables you to comply with users' data removal requests (i.e.
        right to be forgotten). Once a user's

        interactions are deleted, we will not be able to recover them, and they
        will no longer contribute to model

        training.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/InteractionDeleteIn'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InteractionDeleteOut'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /v1/products:
    post:
      tags:
        - Product / Content APIs
      summary: Product / Content Upload API
      operationId: ProductContentApIs_bulkInsert
      security:
        - Secret API Key: []
      description: >-
        Bulk API to insert Product records. This API endpoint accepts POST
        requests with JSON data

        containing a list of Product / Content records wrapped in a dictionary:

        ```

        POST /v1/products


        {"data": [product_1, product_2, product_3]}

        ```


        Each product is uniquely identified by its `product_id`. If a record
        with the same `product_id`

        already exists in the dataset, the existing one will be **replaced** by
        the insertion (no

        partial update is allowed at this time). We recommend limiting your
        calls to around 100

        records at a time to avoid memory issues or timeout risks.


        ### Schema validation

        This API validates the inserted records against the API schema; any
        schema error will cause

        the whole request to fail (`status_code=422`), and none of the records
        will be inserted. You

        should check the `response.errors` field to see if there are any errors.
        For example,

        the response below means there are no errors (`status_code=200`):


        ```json

        {
          "message": "success",
          "data": {
            "task_id": "{task_id}"
          }
        }

        ```


        A common source of errors when uploading Product records is that the
        custom attributes' data

        types are not consistent with the data types of the existing records. In
        such cases,

        you can check the individual error message in the `data` array. For
        example, if there is an

        error regarding the second record you tried to insert, the response
        might look like:


        ```json

        {
          "errors": true, // there are errors. please check!
          "data": [
            "data.0.custom_attributes.designer is invalid. Its data type is not consistent with other records",
            "data.0.product_id is invalid. The attribute expected to be of type 'string', but 'array' is given.",
            "data.0.created_at is invalid. The attribute should match 'date-time' format."
          ]
        }

        ```


        ### Internationalization (I18N)

        Miso has the built-in support for majority of Western European
        languages, including `English`, `French`, `German`,

        `Spanish`, `Italian`, `Dutch`, `Russian`, and `Ukrainian`, as well as,
        major Asian languages, including `Mandarin`
         (both Simplified and Traditional), `Japanese`, and `Korean`.

        In Dojo, you can choose the *Primary Language* for your product catalog
        (default is English).

        However, you can also have more than one language in your product
        catalog that is

        beyond your primary languages using the `i18n_$LN` fields (replace `$LN`
        with the [two-letter language
        code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) of your
        choice),

        and let Miso apply the language-specific preprocessing for you, such as
        tokenization, stemming, elision

        removal, folding, decompounding, and traditional to simplified Chinese
        conversion.


        For example, you may have a product called "Arizona, Green Tea with
        Ginseng & Honey" in your catalog, and you also

        sell it in your Spanish, French, and Chinese sites, and want your
        customers to be able to search for this product

        in their native languages.


        In this case, your product records will like the following sample
        record, where English is the primary language of

        the record, and `i18n_es`, `i18n_fr`, `i18n_zh` fields contain product
        details in their corresponding languages.

        ```javascript

        {
            "product_id": "arizona-ginseng-honey",
            // the primary language is English
            "title": "Arizona, Green Tea with Ginseng & Honey",
            // ... other product details in English
            "i18n_es": {
               "title": "AriZona, Té verde con ginseng y miel"
                // ... other product details in Spanish
            },
            "i18n_fr": {
               "title": "AriZona - Thé Vert Aromatisé au Miel"
                // ... other product details in French
            },
            "i18n_zh": {
               "title": "美國ARIZONA亞歷桑納 - 蜂蜜人蔘綠茶"
                // ... other product details in Chinese
            }
         }
        ```

        In this way, your customer can find this product with any of the
        following search queries

        without additional configuration:

        * `arizona green tea`

        * `arizona te verde`

        * `arizona the vert`

        * `arizona 綠茶`


        The similar concept applies to Autocomplete as well. You can specify a
        `language` parameter

        in the requests to Autocomplete API, and the autocomplete results for
        the specific language

        will be returned.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ProductBulkIn'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateResponse'
        '400':
          description: Bad Request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductContentApIsBulkInsertResponse'
        '401':
          description: Unauthorized
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductContentApIsBulkInsert401Response'
        '403':
          description: Forbidden
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductContentApIsBulkInsert403Response'
        '422':
          description: Unprocessable Entity
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductContentApIsBulkInsert422Response'
        '500':
          description: Internal Server Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductContentApIsBulkInsert500Response'
  /v1/products/{product_id}:
    get:
      tags:
        - Product / Content APIs
      summary: Product / Content Read API
      operationId: ProductContentApIs_getProductDetails
      security:
        - Secret API Key: []
      description: >-
        This API endpoint retrieves the details of a specific product / content
        using its `product_id`.

        To fetch the product / content information, make a GET request to the
        following URL:


        **Notice**: Make sure the product_id is an urlencode string.


        ```

        GET /v1/products/{product_id}

        ```


        Replace `{product_id}` with the unique identifier of the product /
        content you wish to fetch.


        ## Response Format


        The API will return the product / content details in a JSON object if
        the given `product_id`

        is valid and exists in the system. The JSON object will include fields
        like `title`,

        `description`, `price`, `images`, and any internationalization fields
        (`i18n_$LN`).


        ### Example Response


        Here's an example of a successful API response for a product / content
        with the `product_id`

        "arizona-ginseng-honey":


        ```json

        {
          "product_id": "arizona-ginseng-honey",
          "title": "Arizona, Green Tea with Ginseng & Honey",
          "description": "A refreshing and delicious blend of green tea with ginseng and honey.",
          "price": 1.99,
          "i18n_es": {
            "title": "AriZona, Té verde con ginseng y miel"
            // ... other product details in Spanish
          },
          "i18n_fr": {
            "title": "AriZona - Thé Vert Aromatisé au Miel"
            // ... other product details in French
          },
          "i18n_zh": {
            "title": "美國ARIZONA亞歷桑納 - 蜂蜜人蔘綠茶"
            // ... other product details in Chinese
          }
        }

        ```


        If the provided `product_id` is invalid or does not exist in the system,
        the API will return

        an error response with a `status_code=404`.


        ### Example Error Response

        ```json

        {
          "message": "not found"
        }

        ```
      parameters:
        - required: true
          schema:
            title: Product Id
            maxLength: 512
            type: string
          name: product_id
          in: path
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductReadOut'
        '401':
          description: Unauthorized
          content:
            application/json:
              schema:
                $ref: >-
                  #/components/schemas/ProductContentApIsGetProductDetailsResponse
        '404':
          description: Product not Found
          content:
            application/json:
              schema:
                $ref: >-
                  #/components/schemas/ProductContentApIsGetProductDetails404Response
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
        '500':
          description: Internal Server Error
          content:
            application/json:
              schema:
                $ref: >-
                  #/components/schemas/ProductContentApIsGetProductDetails500Response
    delete:
      tags:
        - Product / Content APIs
      summary: Product / Content Delete API
      operationId: ProductContentApIs_deleteProductContent
      security:
        - Secret API Key: []
      description: >-
        This API endpoint allows you to delete a specific product / content from
        the system using its

        `product_id`. To remove a product, make a DELETE request to:


        **Notice**: Make sure the product_id is an urlencode string.


        ```

        DELETE /v1/products/{product_id}

        ```


        Replace `{product_id}` with the unique identifier of the product /
        content you wish to delete.


        ## Response Format


        The API will return a JSON object indicating the success or failure of
        the deletion request.

        If the deletion is successful, the `status_code` will be `200`, and the
        `message` field will

        confirm the successful deletion.


        ### Example Successful Deletion Response


        ```json

        {
          "message": "deleted",
          "data":  [
            {
              "task_id": "{task_id}"
            }
          ]
        }

        ```


        To check the exact response body of this task_id, make a GET request to
        the following endpoint:


        ```

        GET /v1/products/_status/{task_id}

        ```


        Replace `{task_id}` with the task_id returned from the response.
      parameters:
        - required: true
          schema:
            title: Product Id
            maxLength: 512
            type: string
          name: product_id
          in: path
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DeleteResponse'
        '400':
          description: Bad Request
          content:
            application/json:
              schema:
                $ref: >-
                  #/components/schemas/ProductContentApIsDeleteProductContentResponse
        '401':
          description: Unauthorized
          content:
            application/json:
              schema:
                $ref: >-
                  #/components/schemas/ProductContentApIsDeleteProductContent401Response
        '403':
          description: Forbidden
          content:
            application/json:
              schema:
                $ref: >-
                  #/components/schemas/ProductContentApIsDeleteProductContent403Response
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
        '500':
          description: Internal Server Error
          content:
            application/json:
              schema:
                $ref: >-
                  #/components/schemas/ProductContentApIsDeleteProductContent500Response
  /v1/products/_ids:
    get:
      tags:
        - Product / Content APIs
      summary: Product / Content ID List API
      operationId: ProductContentApIs_getProductIds
      security:
        - Secret API Key: []
      description: >-
        This API endpoint allows you to fetch the unique identifiers
        (product_ids) of all products

        stored in the app. To get a list of product_ids, make a GET request to
        the following URL:


        ```

        GET /v1/products/_ids

        ```


        ## Response Format


        The API will return an array of product_ids in a JSON object. The
        `status_code` will be `200`

        if the request is successful. If any error occurs during the request,
        the `status_code` will

        not be `200` and the `message` field will indicate the error.


        ### Example Successful Response


        ```json

        {
          "message": "success",
          "data": {
            "ids": [
              "product_1",
              "product_2",
              "product_3",
              // ... more product_ids
            ]
          }
        }

        ```


        ### Example Error Response


        If the dataset cannot be found, the API will return a `404` error:


        ```json

        {
          "status_code": 404,
          "message": "not found"
        }

        ```


        If another error occurs during the request, the API will return a `500`
        error


        ```json

        {
          "message": "Something went wrong. Please contact miso product team."
        }

        ```
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductListOut'
        '401':
          description: Unauthorized
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductContentApIsGetProductIdsResponse'
        '500':
          description: Internal Server Error
          content:
            application/json:
              schema:
                $ref: >-
                  #/components/schemas/ProductContentApIsGetProductIds500Response
  /v1/products/_delete:
    post:
      tags:
        - Product / Content APIs
      summary: Product / Content Bulk Delete API
      operationId: ProductContentApIs_bulkDelete
      security:
        - Secret API Key: []
      description: >-
        This API endpoint allows you to delete multiple products by providing
        their product_ids.


        To delete multiple products, make a POST request to the following URL:


        ```

        POST /v1/products/_delete

        ```


        The request body should contain a JSON object with an array of
        product_ids:


        ```json

        {
          "data": {
            "product_ids": [
              "product-1",
              "product-2",
              // ... more product_ids to delete
            ]
          }
        }

        ```


        ## Response Format


        The API will return a JSON object with a `message` and an array of
        `data`

        containing a `task_id` that can be used to get the status of the bulk
        deletion process.


        #### Example Successful Response


        ```json

        {
          "message": "deleted",
          "data": {
            "task_id": "{task_id}"
          }
        }

        ```


        To check the exact response body of this task_id, make a GET request to
        the following endpoint:


        ```

        GET /v1/products/_status/{task_id}

        ```


        Replace `{task_id}` with the task_id returned from the response.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ProductBulkDeleteIn'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DeleteResponse'
        '400':
          description: Bad Request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductContentApIsBulkDeleteResponse'
        '401':
          description: Unauthorized
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductContentApIsBulkDelete401Response'
        '403':
          description: Forbidden
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductContentApIsBulkDelete403Response'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
        '500':
          description: Internal Server Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductContentApIsBulkDelete500Response'
  /v1/users:
    post:
      tags:
        - User APIs
      summary: User Upload API
      operationId: UserApIs_bulkUpload
      security:
        - Secret API Key: []
      description: >-
        Bulk API to insert User records. This API endpoint accepts POST requests
        with JSON data

        containing a list of User records wrapped in a dictionary.


        ```

        POST /v1/users

        ```


        ```json

        {
          "data": [user_1, user_2, user_3]
        }

        ```


        If a record with the same `user_id` already exists in the dataset, the
        existing record will

        be replaced (no partial update is allowed at this time). We recommend
        limiting your calls to

        around 100 records at a time to avoid memory issues or timeout risks.


        ### Schema validation


        This API validates the inserted records against the API schema. Any
        schema error will cause

        the whole request to fail (`status_code=422`), and none of the records
        will be inserted. As

        long as the request passes the schema validation, the API will return
        `status_code=200`, but

        you should still check if there is any error occurring with individual
        records.


        ```json

        {
            "errors": true,
            "data": [
                "data.0.user_id is invalid. The attribute was expected to be a `string`"
            ]
        }

        ```


        ## Response Format


        The API will return a JSON object with a `task_id` that can be used to
        retrieve.


        #### Example Successful Response


        ```json

        {
          "data": {
            "task_id": "{task_id}"
          }
        }

        ```


        To check the exact response body of this task_id, make a GET request to
        the following endpoint:


        ```

        GET /v1/users/_status/{task_id}

        ```


        Replace `{task_id}` with the task_id returned from the response.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UserBulkIn'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CreateResponse'
        '400':
          description: Bad Request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsBulkUploadResponse'
        '401':
          description: Unauthorized
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsBulkUpload401Response'
        '403':
          description: Forbidden
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsBulkUpload403Response'
        '422':
          description: Unprocessable Entity
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsBulkUpload422Response'
        '500':
          description: Internal Server Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsBulkUpload500Response'
  /v1/users/{user_id}:
    get:
      tags:
        - User APIs
      summary: User Read API
      operationId: UserApIs_getUserDetails
      security:
        - Secret API Key: []
      description: >-
        This API endpoint retrieves the details of a specific user using their
        `user_id`.

        To fetch the user information, make a GET request to the following URL:


        **Notice**: Make sure the user_id is an urlencode string.


        ```

        GET /v1/users/{user_id}

        ```


        Replace `{user_id}` with the unique identifier of the user you wish to
        fetch.


        ## Response Format


        The API will return the user details in a JSON object if the given
        `user_id` is valid and

        exists in the system. The JSON object will include fields like `name`,
        `age`, `city`, `gender`

        , and other user information.


        ### Example Response


        Here's an example of a successful API response for a user with the
        `user_id` "user123":


        ```json

        {
            "message": "success",
            "data": {
                "user_id": "user123",
                "name": "johndoe",
                // ... other user details
            }
        }

        ```


        If the provided `user_id` is invalid or does not exist in the system,
        the API will return an

        error response with a `status_code=404`.


        ### Example Error Response


        ```json

        {
            "message": "not found"
        }

        ```
      parameters:
        - required: true
          schema:
            title: Userid
            maxLength: 512
            type: string
          name: userId
          in: query
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserReadOut'
        '401':
          description: Unauthorized
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsGetUserDetailsResponse'
        '403':
          description: Forbidden
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsGetUserDetails403Response'
        '404':
          description: User not Found
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsGetUserDetails404Response'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
        '500':
          description: Internal Server Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsGetUserDetails500Response'
    delete:
      tags:
        - User APIs
      summary: User Delete API
      operationId: UserApIs_deleteUser
      security:
        - Secret API Key: []
      description: >-
        This API endpoint allows you to delete a specific user from the system
        using their `user_id`.


        **Notice**: Make sure the user_id is an urlencode string.


        To remove a user, make a DELETE request to:


        ```

        DELETE /v1/users/{user_id}

        ```


        Replace `{user_id}` with the unique identifier of the user you wish to
        delete.


        ## Response Format


        The API will return a JSON object with a `task_id` that can be used to
        retrieve.


        #### Example Error Response


        ```json

        {
          "message": "deleted",
          "data": {
            "task_id": "{task_id}"
          }
        }

        ```


        To check the exact response body of this task_id, make a GET request to
        the following endpoint:


        ```

        GET /v1/users/_status/{task_id}

        ```


        Replace `{task_id}` with the task_id returned from the response.
      parameters:
        - required: true
          schema:
            title: User Id
            maxLength: 512
            type: string
          name: user_id
          in: path
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DeleteResponse'
        '400':
          description: Bad Request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsDeleteUserResponse'
        '401':
          description: Unauthorized
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsDeleteUser401Response'
        '403':
          description: Forbidden
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsDeleteUser403Response'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
        '500':
          description: Internal Server Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsDeleteUser500Response'
  /v1/users/_delete:
    post:
      tags:
        - User APIs
      summary: User Bulk Delete API
      operationId: UserApIs_bulkUserDelete
      security:
        - Secret API Key: []
      description: >-
        This API endpoint allows you to delete multiple users by providing their
        user_ids.


        To delete multiple users, make a POST request to the following URL:


        ```

        POST /v1/users/_delete

        ```


        The request body should contain a JSON object with an array of user_ids:


        ```json

        {
          "data": {
            "user_ids": [
              "product-1",
              "product-2",
              // ... more product_ids to delete
            ]
          }
        }

        ```


        ## Response Format


        The API will return a JSON object with a `message` and an array of
        `data`

        containing a `task_id` that can be used to get the status of the bulk
        deletion process.


        #### Example Successful Response


        ```json

        {
          "message": "deleted",
          "data": {
            "task_id": "{task_id}"
          }
        }

        ```


        To check the exact response body of this task_id, make a GET request to
        the following endpoint:


        ```

        GET /v1/users/_status/{task_id}

        ```


        Replace `{task_id}` with the task_id returned from the response.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UserBulkDeleteIn'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/DeleteResponse'
        '400':
          description: Bad Request
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsBulkUserDeleteResponse'
        '401':
          description: Unauthorized
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsBulkUserDelete401Response'
        '403':
          description: Forbidden
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsBulkUserDelete403Response'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
        '500':
          description: Internal Server Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/UserApIsBulkUserDelete500Response'
  /v1/search/search:
    post:
      tags:
        - Search APIs
      summary: Search API
      operationId: SearchApIs_searchRequest
      security:
        - Secret API Key: []
      description: >-
        The Search API provides personalized, typo-correcting, semantic search
        for your site.

        You send this API the search queries users entered, and the API returns
        the relevant search results tailored to your

        users' interests.


        ### Personalized search

        Personalized search is a key factor in driving search conversion on many
        major sites.

        It is particularly powerful for short search queries (<= 3 keywords),
        which account for [up to 80% of search traffic in the
        U.S.](https://www.statista.com/statistics/269740/number-of-search-terms-in-internet-research-in-the-us/),

        but are usually the hardest to get right with traditional search
        engines. This is because shorter search queries tend

        to match a larger number of results, but there

        is not enough information in the query strings alone to determine which
        results the users

        are actually looking for.


        For example, when users search for *jeans* on Levi's.com, it is

        impossible to know which *jeans* the user is looking for, among
        thousands of options.

        Even if the user adds: *jeans for men*, it is still unclear to a
        traditional search engine what style, material,

        or size the user wants.


        In the contrary, with Miso's personalized search, we not only analyze
        the search query itself, but also take into

        account the *context* in which the searches are made, including who are
        the users, where are they from, what are their

        past interactions on the site, what other searches the user made, etc.
        These signals together

        allow Miso to generate more than 15% to 20% higher search conversion
        rate than the traditional non-personalized search

        engines.


        ### Balancing relevancy and personalization

        Although personalization is a powerful technique, over-using it can be
        harmful to the user experiences. In the

        context of search optimization, the relevancy of the search results are
        still the most important criteria, and we

        don't want personalization to overwhelm the search relevancy.

        For example, when users search for a very specific term, or directly
        search for the product names,

        Miso's algorithm will respond with the most relevant search results
        first, and then only apply personalization to

        rerank more ambiguous search results.



        ### Basic usage

        For every search query, you let Miso know the user's `user_id` and the
        search keywords in the API request body,

        for example:

        ```

        POST /v1/search/search

        {
          "q": "jeans",
          "user_id": "user-123"
        }

        ```


        For site visitors who do not sign in, you can let Miso know the
        `anonymous_id` of this visitor:

        ```

        POST /v1/search/search

        {
          "q": "jeans",
          "anonymous_id": "visitor-123"
        }

        ```


        ### Search response

        With the query above, Miso responds with the search results like the
        following:

        ```javascript

        {
           "message":"success",
           "data":{
              "took":50,
              "total":30,
              "start":0,
              "miso_id":"f34b90de-086b-11eb-b498-1ee8abb1818b",
              "products":[
                 {
                    "product_id":"505-regular-fit-mens-jeans",
                    "title":"The 505 Regular Fit Men's Jeans",
                    "url":"https://levi.com/jeans/505-regular-fit-mens-jeans/",
                    "size":"29",
                    "material":"Cotton",
                    "color":"Rinse - Dark Wash",
                    "_search_score": 78.12,
                    "_personalization_score": 0.98
                 }
              ],
              "spellcheck":{
                 "spelling_errors":false
              }

           }
        }

        ```

        * **took**: the amount of time (in milliseconds) Miso took to answer the
        query

        * **total**: the total number of matched products. You can paginate
        through all the products by using the combination

        of *start* and *rows* parameters (see *Request Body Schema* below)

        * **miso_id**: a UUID of the search request. You should include
        **miso_id** in the Interaction records for every

        interactions that result from this search request, e.g. user
        click-through a product in the search results.

        Miso use miso_id to track the search performance and fine-tune the
        algorithm accordingly.

        * **products**: an array of [Product records](https://api.askmiso.com)
        that match the search

        query, ranked in the order of relevancy and

        probability that the user will be interested in this product. By
        default, only the `product_id` of the Product is

        returned. You can ask Miso to return additional fields by using the *fl*
        parameter (see *Request Body Schema* below)

        * **products[ ]._search_score**: the search relevancy score of the
        products based on keyword matching and Miso's

        semantic matching. This score is similar to traditional Lucene search
        score.

        * **products[ ]._personalization_score**: the score assigned by Miso's
        personalization algorithm based on users'

        profile and their interactions on the site. This score quantifies the
        probability of whether users will be

        interested in this product or not.

        * **spellcheck**: an dictionary contains spell checking information.


        ### Spellcheck and auto-correction

        According to a [Microsoft Research
        study](https://www.aclweb.org/anthology/W04-3238.pdf), roughly 10-15% of
        the

        queries sent to search engines contain errors. A misspelled search
        keyword often results in poor search

        quality, and users have been accustomed to Google's automatic spelling
        correction functionality and expect the same

        on your site.


        However, correcting spelling and typos at scale is a non-trivial machine
        learning problem.

        Miso's spellcheck is based on a sequence-to-sequence

        deep learning model, trained and updated regularly on a corpus of
        billion tokens. It detects hard-to-spot errors,

        auto-correct keywords according to its context, and recognize terms that
        are newer or lesser known.


        Spellcheck is always on for every search request so you don't need to
        turn it on.

        What you need to decide is whether to turn on *auto spelling
        correction*.

        For example, the following search request turns on the
        auto-spelling-correction, and Miso will automatically

        replace any misspelled queries with their correct spelling:

        ```

        POST /v1/search/search

        {
           "q":"whte denem jeans",
           "user_id":"user-123",
           "spellcheck":{
              "enable_auto_spelling_correction":true
           }
        }

        ```

        The API will respond:

        ```javascript

        {
           "message":"success",
           "data":{
              "took":50,
              "total":30,
              "start":0,
              "miso_id":"f34b90de-086b-11eb-b498-1ee8abb1818b",
              "spellcheck":{
                 "spelling_errors":true,
                 "auto_spelling_correction":true,
                 "original_query":"whte denem jeans",
                 "original_query_with_markups":"<mark>whte</mark> <mark>denem</mark> jeans",
                 "corrected_query":"white denim jeans",
                 "corrected_query_with_markups":"<mark>white</mark> <mark>denim</mark> jeans"
              },
              "products":[
                 ......
              ]
           }
        }

        ```

        The *spellcheck* object contains the following fields:

        * **spelling_errors** indicates whether there is a spelling error in the
        query

        * **auto_spelling_correction** indicates whether the search query has
        been replaced with the *corrected_query*

        * **original_query** the original search query

        * **original_query_with_markups** the original search query with the
        misspelled words highlighted by \<mark\> html tags

        * **corrected_query** the search query with misspelling and typos
        corrected

        * **corrected_query_with_markups** the search query with misspelling and
        typos corrected, and the corrected parts are highlighted by \<mark\>
        html tags


        You can opt-out the auto-spelling-correction by setting
        `enable_auto_spelling_correction=false`. For example:

        ```

        POST /v1/search/search

        {
           "q":"whte denem jeans",
           "user_id":"user-123",
           "spellcheck":{
              "enable_auto_spelling_correction":false
           }
        }

        ```

        In this case, Miso will still run spellcheck against the query. However,
        users' queries will be used as it is,

        and **auto_spelling_correction** field will be *false*.


        ### Boosting and Diversification

        While Miso's personalized search can drive conversion by showing search
        results that are tailored

        to users' interests, ultimately, it is important to make sure that the
        search results meet your business goals.

        To that end, Miso provides a great set of tools that enable you to
        fine-tune the search ranking and make it aligned
         with your goals.

        One great example is **boosting**. Boosting allows you to define a query
        that can be used to boost a

        subset of products to the top of the ranking, or to specific *boost
        positions*. You can use boosting to run

        different kinds of promotion campaigns, or to promote certain set of
        products for individual users that you know

        they will be interested in.


        For example, consider a scenario where you need to promote the sales of
        Nike's products. Then, you might want to

        use the query below, that will promote the sneakers whose brand are
        `Nike` to the top of the search result:

        ```

        POST /v1/search/search

        {
           "q":"sneaker",
           "user_id":"user-123",
           "boost_fq": "brand:\"Nike\""
        }

        ```


        For a slightly more complex example, the query below will promote the
        Nike products which have also been tagged

        as `ON SALE`:

        ```

        POST /v1/search/search

        {
           "q":"sneaker",
           "user_id":"user-123",
           "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
        }

        ```


        You can have as complex boosting logic as you want in the boosting
        query,

        but it is worth mentioning that Miso will only boost

        products that are relevant and have high likelihood to convert. In other
        words, Miso will not boost low

        performance products even if they match the boosting query.


        Depending on your boosting rules, in certain cases, you would like to
        prevent search results from becoming

        too "plain" due to boosting. For example, you don't want the first page
        of the search result to contain only Nike

        products.


        With Miso, you have two tools to avoid so. First, you can specify
        `boost_positions` to place boosted products at

        specific positions in the ranking. For example, the query below will
        place boosted products only at the first,

        fourth, seventh places in the ranking (positions are 0-based), and place
        the remaining products in their original

        ranking, skipping these three positions.


        ```

        POST /v1/search/search

        {
           "q":"sneaker",
           "user_id":"user-123",
           "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
           "boost_positions": [0, 3, 6]
        }

        ```


        The second tool is `diversification`. Miso's `diversification` algorithm
        will maintain a desired minimum distance

        between any two products that have the same attributes. For example, the

        following query will make sure products made by the same *brand* are at
        least two slots apart from each

        other in the search results.


        ```

        POST /v1/search/search

        {
           "q":"sneaker",
           "user_id":"user-123",
           "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
           "diversification": {
               "brand": {"minimum_distance": 2}
            }
        }

        ```


        It is also very often to use both "boost_positions" and
        "diversification" at the same time to make sure that

        (1) the search results are not overwhelmed by the boosted products, and
        (2) there is a good mix of products from

        different brands showing side-by-side to increase product discovery
        rate.


        ### Result ordering


        You can override Miso's default ranking order by specifing a list of
        fields for Miso to rank the search results.

        These fields can be any numeric or boolean fields in your Product
        catalog, or one of the following special

        fields:

        * **_personalization_score**: the score that estimates the probability
        that a user will interact with a product

        determined by Miso's personalization algorithm. The range of this score
        is between [0, 1]. The scores are

        non-uniformly distributed. The Products that are relevant to users'
        interests will have scores much closer to 1,

        than products that are not.

        * **_search_score**: the score that rates the degree of "match" between
        search keywords and a product's catalog

        with a focus on Product's titles.

        This score is mostly based on a variant of
        [BM25](https://en.wikipedia.org/wiki/Okapi_BM25), but additionally

        consider the term proximity, typos, term semantic similarity.

        Its value is always larger than 0, but its range is unbounded.

        * **_boosting_score**: a binary score indicates whether a Product is
        boosted by your boosting query.

        * **_geo_distance**: distance between any point on map, `geo` must be
        specified when sorting with this field.


        For example, the following query returns all the Products (because
        `q=*`), ranked by the `_personalization_score`

        first, and then by the values in the `custom_attributes.promote_score`
        field in the Product catalog, then the

        distance between the product and New York city.

        ```

        {
          "q": "*",
          "order_by": [
                {
                    "field": "_personalization_score",
                    "tie_breaker": {
                        "type": "relative_difference",
                        "threshold": "0.05"
                    },
                    "order": "desc"
                },
                {
                    "field": "custom_attributes.promote_score",
                    "order": "desc"
                },
                {
                    "field": "_geo_distance",
                    "geo": {
                        "lat": 40.711967,
                        "lon": -74.006076,
                    }
                    "order": "asc"
                }
          ]
        }

        ```

        #### Mathematical Functions

        Miso supports mathematical functions that transform and combine
        different sorting criteria into one.

        For example, a powerful strategy to improve gross merchandise volume
        (GMV), but maintain user

        experience is

        to sort the products based on the multiplication of personalization
        scores and product prices. You can achieve this with

        the following `order_by` query:

        ```

        {
          "q": "*",
          "order_by": [
                {
                    "field": "_personalization_score * pow(sale_price, 0.5)",
                    "order": "desc"
                }

          ]
        }

        ```

        Function `pow(sale_price, 0.5)` takes the square root of the sale price
        and avoids very expensive products from

        overwhelming the ranking.


        Miso supports all the common mathematical operators including `+`, `-`,
        `*`, `/`, `%`, `^`, `**`, and more

        advanced functions including:
          * Power functions: `pow(X, y)`, `sqrt(X)`
          * Exponents and logarithms: `exp(X)`, `log(X)`, `log2(X)`, `log10(X)`
          * Element-wise maximum / minimum: `maximum(X, y)`, `minimum(X, y)`
          * Absolute function: `abs(X)`
          * Rounding functions: `round(X)`, `floor(X)`, `ceil(X)`
          * Trigonometric functions: `sin(X)`, `cos(X)`, `tan(X)`, `asin(X)`, `acos(X)`, `atan(X)`


        #### Soft Tie-Breaker

        For scores that have granular resolutions, for example
        `_personalization_score`,`_search_scores`, or

        Products' `sale_price`, we usually don't want to rank Products by their
        raw values. After all,

        a 0.001 difference in `_personalization_score` or $0.01 difference in
        sale price typically will not make a

        difference in users' preferences. In such cases, *soft* tie-breakers
        should be used to smooth out these minor

        differences in scores.


        For example, in the query above, we apply a soft tie-breaker to
        `_personalization_score` based on score values'

        relative difference. Specifically, we first sort the score's raw values
        in the descending order, then

        for two consecutive values, if their relative difference is no more than
        a pre-defined threshold

        (in this case `0.05` or `5%`), they are considered as a tie, and the
        next field

        (i.e. `custom_attributes.promote_score`)

        will be used to determine their ranking.


        It is also common to utilize tie-breakers to combine the effect of two
        types of scores. For example, in the

        following query, we set `threshold=0.2` or `20%` for
        `_personalization_score`, then only the

        Products that users are 20% more likely to interact with will be ranked
        higher, the remaining Products will be

        ranked by their sale prices. In this way, we combine the effect of
        personalization score and sale prices, where

        the Products are roughly ranked by personalization, but favor the
        pricier products when they have comparable

        personalization scores.

        ```

        {
          "q": "*",
          "order_by": [
                {
                    "field": "_personalization_score",
                    "tie_breaker": {
                        "type": "relative_difference",
                        "threshold": "0.20"
                    },
                    "order": "desc"
                },
                {
                    "field": "sale_price",
                    "order": "desc"
                }

          ]
        }

        ```


        Also note that, when search keywords are present, it is recommended to
        always include `_search_score`

        as the first field (plus a tie-breaker) to maintain the relevance of the
        search results. A tie-breaker is usually

        required as well to let the subsequent score have effect to the ranking.

        ```

        {
          "q": "toy story",
          "order_by": [
              {
                    "field": "_search_score",
                    "tie_breaker": {
                        "type": "relative_difference",
                        "threshold": "0.20"
                    },
                    "order": "desc"
                },
                {
                    "field": "_personalization_score",
                    "tie_breaker": {
                        "type": "relative_difference",
                        "threshold": "0.20"
                    },
                    "order": "desc"
                },
                {
                    "field": "sale_price",
                    "order": "desc"
                }

          ]
        }

        ```
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/SearchRequest'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/SearchResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /v1/search/autocomplete:
    post:
      tags:
        - Search APIs
      summary: Autocomplete API
      operationId: SearchApIs_autocompleteRequest
      security:
        - Secret API Key: []
      description: >-
        The Autocompletion API provides real-time, personalized, typo resistant
        typeahead for your search bar.

        You send this API what users are currently typing, and the API returns
        the complete search query suggestions.


        ### Personalized typeahead

        Personalized typeahead is an extreme example of personalized search. The
        personalization starts immediately when

        users enter even just one character. The typeahead results are
        personalized so that the entries most likely to drive

        conversion for the current user are ranked at the top. Miso will predict
        what the user is looking for in real-time

        based on their interests and past behaviors.


        ### Basic usage

        The request schema of Autocompletion API is similar to that of Search
        API: you put the search query users typed so

        far, and the `user_id` or `anonymous_id` for Miso to identify the
        current user.

        For example, when a user types the first character `r`, you send Miso
        the following request:

        ```

        POST /v1/search/autocomplete

        {
           "q":"r",
           "user_id":"user-123"
        }

        ```


        The response will be like:

        ```javascript

        {
          "message": "success",
          "data": {
            "took": 50,
            "miso_id": "e93a6d02-0a7a-11eb-a896-d28586dc1386",
            "completions": {
              "title": [
                {
                  "text": "Robin Hood: Prince of Thieves (1991)",
                  "text_with_markups": "R<mark>obin Hood: Prince of Thieves (1991)</mark>",
                  "product": {
                    "product_id": "tmdb-8367"
                  }
                },
                {
                  "text": "Reservoir Dogs (1992)",
                  "text_with_markups": "R<mark>eservoir Dogs (1992)</mark>",
                  "product": {
                    "product_id": "tmdb-500"
                  }
                },
                ...
              ]
            }
          }
        }

        ```

        * **took**: the amount of time (in milliseconds) Miso took to answer the
        query

        * **completions**: an dictionary of autocompletion candidates from
        different sources. By default, we only run

        autocompletion against the titles of products, but you can choose to get
        autocompletion candidates from other fields

        using the `completion_fields` parameters.

        * **completions.title[].text**: the text of completion candidates

        * **completions.title[].text_with_markups**: the completion candidates
        with the part of text that users

        haven't typed yet surrounded by \<mark\> HTML tags.

        * **completions.title[].product**: the product record whose title
        matches the autocompletion candidate. This object can be used to
        implement direct-to-product links: when they click on the link they will
        go

        directly to the product page instead of the search result page. By
        default, only the `product_id` field is returned,
         you use `fl` request parameter to get more fields returned in the product object.


        ### Typo resistance

        Miso's autocompletion algorithm accepts up to 4 typos in the query
        string. For example, users may try to find the
         movie `Robin Hood`, but make two typos in the query, which becomes `robonhood` instead (`robin`->`robon`, and a space is missing).

        ```

        POST /v1/search/autocomplete

        {
           "q":"robanhood",
           "user_id":"user-123"
        }

        ```


        Miso can still find the movie "*Robin Hood: Prince of Thieves*" as a
        autocompletion candidate.

        ```javascript

        {
          "message": "success",
          "data": {
            "took": 50,
            "miso_id": "e93a6d02-0a7a-11eb-a896-d28586dc1386",
            "completions": {
              "title": [
                {
                  "text": "Robin Hood: Prince of Thieves (1991)",
                  "text_with_markups": "Rob<mark>in Hood: Prince of Thieves (1991)</mark>",
                  "product": {
                    "product_id": "tmdb-8367"
                  }
                },
                ...
              ]
            }
          }
        }

        ```


        ### Completion fields

        The auto-completions are made against your product attributes. By
        default, Miso finds completion candidates from the

        `title` field. The `completion_fields` parameter

        lets you specify the attributes you want to perform auto-completion for.

        For example, the following query will return auto-completion candidates
        from the `title` and a custom attribute

        field:`custom_attributes.director`.

        ```

        POST /v1/search/autocomplete

        {
          "q": "rob",
          "user_id": "user-123",
          "completion_fields": [
            "title",
            "custom_attributes.director"
          ]
        }

        ```

        The response will be like the following:

        ```javascript

        {
          "message": "success",
          "data": {
            "took": 52,
            "miso_id": "16d95080-0bb0-11eb-948d-66359cf29022",
            "completions": {
              "title": [
                {
                  "text": "Robin Hood: Prince of Thieves (1991)",
                  "text_with_markups": "Rob<mark>in Hood: Prince of Thieves (1991)</mark>",
                  "product": {
                    "product_id": "tmdb-8367"
                  }
                },
                {
                  "text": "RoboCop (1987)",
                  "text_with_markups": "Rob<mark>oCop (1987)</mark>",
                  "product": {
                    "product_id": "tmdb-5548"
                  }
                },
                ...
              ],
              "custom_attributes.director": [
                {
                  "text": "Robert Z. Leonard",
                  "text_with_markups": "<mark>Rob</mark>ert Z. Leonard",
                },
                ...
              ]
            }
          }
        }

        ```
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/AutocompleteRequest'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AutocompleteResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /v1/search/mget:
    post:
      tags:
        - Search APIs
      summary: Multiple Get API
      operationId: SearchApIs_multipleGetProducts
      security:
        - Secret API Key: []
      description: >-
        The Multiple Get API provides a simple and fast interface to retrieve
        Products by their product ids.

        For example, the following query will retrieve products whose
        product_ids are `123ABC-S-Black` and `123ABC-S-Blue`

        ```

        {
            "product_ids": ["123ABC-S-Black", "123ABC-S-Blue"]
        }

        ```

        Miso will respond with the complete Products records in the same order
        as the given `product_ids`:

        ```

        {
          "message": "success",
          "data": {
            "products": [
              {
                "_found": true,
                "product_id": "123ABC-S-Black",
                "title": "Product ABC in Black",
                ...
              },
              {
                "_found": true,
                "product_id": "123ABC-S-Blue",
                "title": "Product ABC in Blue",
                ...
              }
            ]
          }
        }


        ```

        You can use the `_found` field to determine whether a product is found
        in the Miso database or not.

        When the given product_id is not found, the `_found` field in the
        corresponding Product record

        will become `false`.


        For example, the following query requests a `product_id` that does not
        exist in the Miso database:

        ```

        {
            "product_ids": ["Product_Not_Exists", "123ABC-S-Black"]
        }

        ```

        Miso will respond:

        ```

        {
          "message": "success",
          "data": {
            "products": [
              {
                "_found": false,
                "product_id": "Product_Not_Exists"
              },
              {
                "_found": true,
                "product_id": "123ABC-S-Black",
                "title": "Product ABC in Black",
                ...
              }
            ]
          }
        }

        ```

        Finally, like every Miso API, you can use `fl` to control what Product
        fields to return. By default, all the Product

        fields will be returned, but the following query will return only
        `title` field of the product (in addition

        to `product_id`)

        ```

        {
            "product_ids": ["123ABC-S-Black", "123ABC-S-Blue"],
            "fl": ["title"]
        }

        ```
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/MultipleGetRequest'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/MultipleGetResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /v1/ask/questions:
    post:
      tags:
        - Ask APIs
      summary: Create a new qestion
      operationId: AskApIs_submitQuestion
      security:
        - Secret API Key: []
      description: |-
        This API is used to submit questions to Miso.

        After a question is submitted, a `question_id` is returned.
        Then you can use `question_id` to check the latest status of it's answer
        as it is being compiled.
            
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/QuestionRequest'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QuestionResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /v1/ask/questions/{question_id}/answer:
    get:
      tags:
        - Ask APIs
      summary: Get latest answer of asked question
      operationId: AskApIs_getAnswerStage
      security:
        - Secret API Key: []
      description: >-
        This API is used to fetch the latest answer of previous submitted
        question from Miso


        A submitted question is put into a job with following stage:


        - Initialization

        - Parsing and fecthing related content

        - Relevance checking

        - Summarization


        This API will tell you at what stage current question is in.

        If answer is fetched and being summerized, it will also return the
        latest summarization result.


        Besides human readable answer, the products used to generate answer are
        also returned.
            
      parameters:
        - required: true
          schema:
            title: Question Id
            type: string
            format: uuid
          name: question_id
          in: path
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/PollAnswerResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /v1/recommendation/user_to_products:
    post:
      tags:
        - Recommendation APIs
      summary: User to Products API
      operationId: RecommendationApIs_getRecommendedProducts
      security:
        - Secret API Key: []
      description: >-
        Returns the products that are most likely to drive conversion for the
        given user. Depending on the conversion

        metrics you choose when training your Miso Engines in Dojo, this API
        returns products that are most likely to

        optimize those metrics (such as `add_to_cart`, `checkout`, or `read`).


        This API considers both user's interests and the conversion probability.
        The user's interests are determined from

        their past interactions on the site and the context of their current
        browsing session, including recent trending

        products, time of the day, recent search behaviors, etc.


        ### Application scenarios

        The User to Products API is usually used in homepage recommendations,
        such as "*Inspired by your shopping trends*" on

        Amazon, or "*Recommended videos*" on Youtube. It can also be used to run
        an email marketing campaign such as a

        newsletter from Medium with recent articles you might like. These kind
        of recommendations are particularly powerful

        in driving product discovery.


        ### Basic usage

        For basic usage of this API, you just need to let Miso knows the id of
        the current user or visitor via `user_id`

        or `anonymous_id` field. For example, for a currently logged-in user,
        your request may look like the following:

        ```

        POST /v1/recommendation/user_to_products

        {"user_id": "user-123"}

        ```

        For a un-signed visitor, your request may look like the following:

        ```

        POST /v1/recommendation/user_to_products

        {"anonymous_id": "visitor-123"}

        ```


        This API will respond with the recommended products for the specified
        user or visitor:

        ```javascript

        {
          "message": "success",
          "data": {
            "took": 37,
            "miso_id": "517452b0-0ccf-11eb-948d-66359cf29022",
            "products": [
              {
                "product_id": "tmdb-475557",
                "_personalization_score": 0.91
              },
              {
                "product_id": "tmdb-299534",
                "_personalization_score": 0.89
              },
              ...
            ]
          }
        }

        ```

        * **took**: the amount of time (in milliseconds) Miso took to answer the
        query

        * **miso_id**: a UUID of the search request. You should include
        **miso_id** in the Interaction records for every

        interactions that result from this search request, e.g. user
        click-through a product in the search results.

        Miso use miso_id to track the search performance and fine-tune the
        algorithm accordingly.

        * **products**: an array of [Product records](https://api.askmiso.com)
        recommended to this

        user ranked by the probability that the user will be interested in this
        product. By default, only the `product_id`

        of the Product is returned. You can ask Miso to return additional fields
        by using the *fl* request argument (see example below)

        * **products[ ]._personalization_score**: the score assigned by Miso's
        personalization algorithm based on users'

        profile and their interactions on the site. This score quantifies the
        probability of whether users will be

        interested in this product or not.


        You can use the `fl` request argument to ask Miso to return more product
        fields. For example, the following request

        asks Miso to additionally return the *title* and *category* fields of
        every recommended product:

        ```

        POST /v1/recommendation/user_to_products

        {
            "user_id": "user-123",
            "fl": ["title", "categories"]
        }

        ```

        The response will be like:

        ```javascript

        {
          "message": "success",
          "data": {
            "took": 37,
            "miso_id": "517452b0-0ccf-11eb-948d-66359cf29022",
            "products": [
              {
                "product_id": "tmdb-475557",
                "categories": [
                  [
                    "Crime"
                  ],
                  [
                    "Thriller"
                  ],
                  [
                    "Drama"
                  ]
                ],
                "title": "Joker (2019)",
                "_personalization_score": 0.91
              },
              {
                "product_id": "tmdb-299534",
                "categories": [
                  [
                    "Adventure"
                  ],
                  [
                    "Science Fiction"
                  ],
                  [
                    "Action"
                  ]
                ],
                "title": "Avengers: Endgame (2019)",
                "_personalization_score": 0.89
              },
             ...
            ]
          }
        }

        ```

        ### Filtering and Boosting

        Like every other Miso API, `User To Products` API supports filter query
        (`fq`) and boost query (`boost_fq`) to

        generate recommendations that meet your business needs.


        #### Filter Query

        You can use filter query to filter recommendation results against

        arbitrary criteria, and Miso will *guarantee* to return sufficient
        number of recommendation results that meet the

        criteria. For example, the following requests will limit the
        recommendations to only `Drama` films:

        ```

        POST /v1/recommendation/user_to_products

        {
            "user_id": "user-123",
            "fl": ["title", "categories"],
            "fq": "categories:Drama"
        }

        ```


        For another example with `custom_attributes`, the following requests
        will limit the recommendations to
         only `Drama` films after `2010`:
        ```

        POST /v1/recommendation/user_to_products

        {
            "user_id": "user-123",
            "fl": ["title", "categories"],
            "fq": "categories:Drama AND custom_attributes.year:[2010 to *]"
        }

        ```


        #### Latency Consideration

        Miso achieves **instant** recommendations by pre-computing a large pool
        of candidates (N>1,000)

        for each user with the products they are mostly likely to be interested
        in. However, when the given filter query do

        not match a sufficient number of

        candidates, Miso will fall back to Search API to find additional matches
        to fill in the remaining

        slots. While falling back to Search API will increase the latency, the
        latency increase is usually minimum if the

        same filter query is being used repeatedly due to Miso's caching
        mechanism.



        #### Boost Query

        You can use `boost_fq` to boost Products with arbitrary criteria. The
        relevant Products that match the `boost_fq`

        will be ranked at the top of the recommendations or at the positions
        specified in the

        `boost_positions` parameter. Boosting is particularly useful for product
        promotions (e.g. sponsored products) to

        highlight the Products you want more impression.


        For example, the following request will boost the `Sci-Fi` films
        directed by `Ridley Scott`:

        ```

        POST /v1/recommendation/user_to_products

        {
            "user_id": "user-123",
            "fl": ["title", "categories"],
            "boost_fq": "categories:\"Sci-Fi\" AND custom_attributes.director:\"Ridley Scott\""
        }

        ```

        The response will be like:


        ```javascript

        {
          "message": "success",
          "data": {
            "took": 83,
            "miso_id": "54bf6d9a-dd32-11eb-99d6-a62d401473b5",
            "products": [
              {
                "product_id": "tmdb-286217",
                "title": "The Martian (2015)",
                "_personalization_score": 0.5364759309088403,
                "_boosted": true,
                "categories": [
                  [
                    "Drama"
                  ],
                  [
                    "Adventure"
                  ],
                  [
                    "Science Fiction"
                  ]
                ]
              },
              ...
            ]
          }
        }

        ```

        The additional field **products[ ].boosted** is a boolean that indicates
        whether the Product matches the `boost_fq`.


        You can also use `boost_positions` to specify the positions in the
        recommendation list you want the

        boosted Products to be placed. For example, the following request will
        place the boosted Product at the second place,

        and the third place (the `boost_positions` are 0-based):


        ```

        POST /v1/recommendation/user_to_products

        {
            "user_id": "user-123",
            "fl": ["title", "categories"],
            "boost_fq": "categories:\"Sci-Fi\" AND custom_attributes.director:\"Ridley Scott\"",
            "boost_positions": [1, 2]
        }

        ```


        ### Filtering "already seen" items

        Typically, the User to Products API is used to let users discover new
        products they might be interested in. Therefore,

        it is important not to recommend products users have already interacted
        with recently. By default, the User to Products

        API filters out the most recent 50 products users have had interactions
        with (except for `impression` interactions)
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UserToItemsRequest'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/RecResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /v1/recommendation/user_to_categories:
    post:
      tags:
        - Recommendation APIs
      summary: User to Categories API
      operationId: RecommendationApIs_getUserCategories
      security:
        - Secret API Key: []
      description: >-
        The User to Categories API returns the product categories that will
        drive the conversion for the current user,

        along with the recommended products for each returned category.


        ### Application scenarios

        This API is usually used in homepage recommendations, or category
        recommendations

        where recommendations are organized by categories,

        such as Netflix's "*Action / Sci-Fi / Drama movies for you*"

        or Amazon's "*Recommendations for you in Grocery & Gourmet Food*". The
        goal of such recommendations is to help

        users discover attractive products under the categories they

        have a high chance to be interested in.


        ### Basic usage

        For basic usage of this API, you just need to let Miso knows the
        `user_id` or

        `anonymous_id` of the current users. Miso will return a list of top
        categories along with the recommended

        Products under each of the categories.

        ```

        POST https://api.askmiso.com/v1/recommendation/user_to_categories

        {
            "user_id": "user-123",
            "rows": 2,
            "products_per_category": 3,
            "fl": ["title"]
        }

        ```

        * **rows**: the number of categories to return

        * **products_per_category**: the number of Products to return per each
        category

        * **fl**: like in other Miso API, you can use `fl` to control which
        fields to return for each Product


        The response of this request will be like:

        ```

        {
          "message": "success",
          "data": {
            "took": 85,
            "miso_id": "7cd6059c-dd54-11eb-8050-a62d401473b5",
            "categories": [
              {
                "category": [
                  "Drama"
                ],
                "total": 61510,
                "recommended_products": [
                  {
                    "product_id": "tmdb-286217",
                    "title": "The Martian (2015)"
                  },
                  {
                    "product_id": "tmdb-281957",
                    "title": "The Revenant (2015)"
                  },
                  {
                    "product_id": "tmdb-68718",
                    "title": "Django Unchained (2012)"
                  }
                ]
              },
              {
                "category": [
                  "Thriller"
                ],
                "total": 21870,
                "recommended_products": [
                  {
                    "product_id": "tmdb-11324",
                    "title": "Shutter Island (2010)"
                  },
                  {
                    "product_id": "tmdb-1949",
                    "title": "Zodiac (2007)"
                  },
                  {
                    "product_id": "tmdb-1422",
                    "title": "The Departed (2006)"
                  }
                ]
              }
            ]
          }
        }

        ```

        * **categories**: a list of categories recommended to the users.

        * **categories[].category**: the recommended category in the format of
        category hierarchy. `["Sci-Fi"]` is a top level category,

        `["Sci-Fi", "Space Travel"]` is a second-level category under `Sci-Fi`
        (a.k.a subcategory).

        * **categories[].total**: the total number of Products belonging to the
        category

        * **categories[].recommended_products**: a list of Products (in that
        category) recommended to the users


        ### Root Category

        By default, `User To Categories` API recommends top level categories,
        but you can change this behavior

        via `root_category` parameter. Miso will recommend the immediate
        sub-categories of the given `root_category`

        For example, the following request will recommend sub-categories under

        `Science Fiction`, for example `["Science Fiction", "Space Travel"]` or
        `["Science Fiction", "Steampunk"]`:

        ```

        POST https://api.askmiso.com/v1/recommendation/user_to_categories

        {
            "user_id": "test",
            "root_category": ["Science Fiction"]
        }

        ```


        In some cases, you may want to get recommendations from *any*
        subcategories (regardless their parent category).

        In such case, you can use wildcard `*` to achieve such results. For
        example, the following request will recommend

        any sub-categories regardless their parent category:

        ```

        POST https://api.askmiso.com/v1/recommendation/user_to_categories

        {
            "user_id": "test",
            "root_category": ["*"]
        }

        ```

        ### Filter and boost query

        Like every Miso API, `User To Categories` supports `fq` for filtering,
        and `boost_fq` for boosting. You can use

        these parameters to make the recommendation results meet your exact
        business needs. For example, the following

        request will recommend categories

        that contain sufficient number of Products that meet the `fq` criteria
        (i.e. films after 2010), and each Product

        returned in the `recommended_products` list will also meet the `fq`
        criteria:

        ```

        POST https://api.askmiso.com/v1/recommendation/user_to_categories

        {
            "user_id": "user-123",
            "rows": 2,
            "products_per_category": 3,
            "fq": "custom_attributes.year: [2010 TO *]"
        }

        ```

        Similarly, you can use `boost_fq` to promote Products that meet your
        business criteria in each category. For example,

        the following request will prioritize Products that are promoted
        (indicated by `custom_attributes.promoted`):

        ```

        POST https://api.askmiso.com/v1/recommendation/user_to_categories

        {
            "user_id": "user-123",
            "rows": 2,
            "products_per_category": 3,
            "boost_fq": "custom_attributes.promoted: true"
        }

        ```

        ### Latency considerations

        `User To Categories` API is one of more complex API because it needs to
        first identify categories the user will be

        interested in, and then find the top Products in that categories. We
        make this process real-time by pre-computing a

        large number of top Products users may find interesting in for each
        category, therefore the end-to-end latency is

        usually under 100ms. To further reduce the latency, you can:

        * Use a smaller `products_per_category` to reduce number of products to
        return, or set it to zeros if you don't need any.

        * Request only the necessary fields using `fl` parameters

        * Use a smaller `rows` to reduce number of categories to return
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UserToCategories'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/CategoryRecResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /v1/recommendation/user_to_attributes:
    post:
      tags:
        - Recommendation APIs
      summary: User to Attributes API
      operationId: RecommendationApIs_getUserAttributes
      security:
        - Secret API Key: []
      description: >-
        The `User to Attributes` API is a generalized version of `User to
        Categories` API --- it returns the product

        attributes that Miso expects to drive a conversion for the current

        user. You specify a field in your Product catalog you want
        recommendations for, e.g. the `brand` or a custom field like

        `custom_attributes.director`, and this API will return a list of values
        from that fields Miso expects users will be most

        interested in, as well as a list of personalized product suggestions.


        ### Applicable scenarios

        This API is usually used in homepage recommendations, where users can
        interact with recommended attributes.

        For example, this API could generate suggestions for "the brands you may
        like" or "the creators you may like."


        ### Basic usage

        For basic usage of this API, you just need to let Miso knows the
        `user_id` or `anonymous_id`, and the `field` you

        want to get recommendations for. For example, the following request will
        return the recommended `director` for

        the given users:

        ```

        POST https://api.askmiso.com/v1/recommendation/user_to_attributes

        {
            "user_id": "test",
            "field": "custom_attributes.director",
            "rows": 3,
            "products_per_attribute": 2,
            "fl": ["title"]
        }

        ```

        * **field**: the name of the field you want to get recommendation for

        * **rows**: the number of categories to return

        * **products_per_attribute**: the number of Products to return per each
        attribute

        * **fl**: like in other Miso API, you can use `fl` to control which
        fields to return for each Product


        The response of this request will be like:

        ```javascript

        {
          "message": "success",
          "data": {
            "took": 296,
            "miso_id": "9d7c8d9c-dd73-11eb-b20d-9a566192e5c6",
            "attributes": [
              {
                "value": "Christopher Nolan",
                "total": 12,
                "recommended_products": [
                  {
                    "product_id": "tmdb-272",
                    "title": "Batman Begins (2005)"
                  },
                  {
                    "product_id": "tmdb-77",
                    "title": "Memento (2000)"
                  }
                ]
              },
              {
                "value": "Ridley Scott",
                "total": 26,
                "recommended_products": [
                  {
                    "product_id": "tmdb-286217",
                    "title": "The Martian (2015)"
                  },
                  {
                    "product_id": "tmdb-4982",
                    "title": "American Gangster (2007)"
                  }
                ]
              },
              {
                "value": "Quentin Tarantino",
                "total": 13,
                "recommended_products": [
                  {
                    "product_id": "tmdb-680",
                    "title": "Pulp Fiction (1994)"
                  },
                  {
                    "product_id": "tmdb-68718",
                    "title": "Django Unchained (2012)"
                  }
                ]
              }
            ]
          }
        }


        ```

        * **attributes**: a list of attributes recommended to the users.

        * **attributes[ ].value**: the recommended attribute value (in this
        case, director name)

        * **attributes[ ].total**: the total number of Products that have this
        attribute

        * **attributes[ ].recommended_products**: a list of Products (with the
        attribute) recommended to the users
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UserToAttributes'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AttributeRecResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /v1/recommendation/user_to_trending:
    post:
      tags:
        - Recommendation APIs
      summary: User to Trending API
      operationId: RecommendationApIs_getUserTrending
      security:
        - Secret API Key: []
      description: >-
        The User to Trending API returns the products that are currently
        trending

        and are most likely to be of interest to this user. It's different from
        the User to Products API because it will only

        recommend trending products. However, each user should still see unique
        recommendations that are not only trending but

        also suit their interests.


        ### Applicable scenarios

        This API is typically used to make homepage recommendations such as
        "Trending products for users like you" or

        "Trending on Youtube".


        ### Filtering "already seen" items

        The User to Trending API will not recommend products users have recently
        interacted with.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UserToItemsRequest'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/TrendRecResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /v1/recommendation/product_to_products:
    post:
      tags:
        - Recommendation APIs
      summary: Product to Products API
      operationId: RecommendationApIs_getRelatedProducts
      security:
        - Secret API Key: []
      description: >-
        The Product to Products API returns the products that are related to an
        anchor product (often the product the user

        is currently engaging with) and are also likely to drive conversions by
        connecting with the user’s interests. It is

        different from the User to Products API as it not only considers the
        user’s interests but also considers the

        recommended products' relevancy to the anchor product.


        ### Applicable scenarios

        This API is frequently used in product detail page to show related
        products that users can consume

        further, such as "Related products you may like" on Amazon or "Up next
        video" on Youtube. It is one of Miso's best

        performing APIs. Our customers usually see more than 30% and some times
        110% relative lift in click-through rate after

        deploying this a feature using this API.


        ### Basic usage

        To use this API, you just need to let Miso knows the `user_id` (or
        `anonymous_id`) and the `product_id` you

        want to get related recommendations for. For example, the following
        request will return the products that are

        related to the movie `Toy Story`.

        ```

        POST https://api.askmiso.com/v1/recommendation/product_to_products

        {
            "user_id": "user_123",
            "product_id": ["toy-story-1995"],
            "rows": 3,
            "fl": ["title"]
        }

        ```

        * **product_id**: the id of the anchor product

        * **rows**: the number of related products to return

        * **fl**: like in other Miso API, you can use `fl` to control which
        fields to return for each Product


        The response will be like:

        ```javascript

        {
            "message": "success",
            "data": {
                "took": 56,
                "miso_id": "f98b1904-ddce-11eb-be53-fa1729b23183",
                "products": [
                    {
                        "product_id": "toy-story-2-1999",
                        "title": "Toy Story 2 (1999)"
                    },
                    {
                        "product_id": "toy-story-3-2010",
                        "title": "Toy Story 3 (2010)"
                    },
                    {
                        "product_id": "the-lion-king-1994",
                        "title": "The Lion King (1994)"
                    }
                ]
            }
        }

        ```

        * **products**: a list of products related to the anchor product

        * **products[ ].product_id**: the id of the recommended product

        * **products[ ].title**: the title of the recommended product. You can
        use `fl` parameter to make Miso return more fields


        ### Boosting and filtering

        Like every Miso API, you can utilize `fq` and `boost_fq` to fine-tune
        the recommendations returned by Miso, and

        Miso will guarantee to return the required number of recommendations
        that meet the given criteria.


        For example, the following request still recommends movies related to
        "Toy Story" but limits the recommendations

        to only the movies released after year 2010.

        ```

        POST https://api.askmiso.com/v1/recommendation/product_to_products

        {
            "user_id": "user_123",
            "product_id": ["toy-story-1995"],
            "rows": 3,
            "fl": ["title"],
            "fq": "custom_attributes.year: [2010 TO *]"
        }

        ```


        For another example, the following request will *boost* the movies that
        are acted by `Tom Hanks`. The boosting is

        different from filtering as it only prioritizes those products that
        match the boosting criteria and are relevant to

        the anchor products, but it will not limit the results to only such
        products.

        ```

        POST https://api.askmiso.com/v1/recommendation/product_to_products

        {
            "user_id": "user_123",
            "product_id": ["toy-story-1995"],
            "rows": 3,
            "fl": ["title"],
            "boost_fq": "custom_attributes.actors:\"Tom Hanks\""
        }

        ```


        ### Multiple anchor products

        In the scenarios where you want to recommend products related to
        **multiple** anchor products, for example,

        for shopping cart cross-sell or up-sell, you can utilize `product_ids`

        parameter and have multiple product ids in it.


        For instance, the following request recommends products related to
        movies "Toy Story" and "Monsters, Inc."

        that will be of interest to the the current user.

        ```

        POST https://api.askmiso.com/v1/recommendation/product_to_products

        {
            "user_id": "user_123",
            "product_ids": ["toy-story-1995", "monsters-inc-2001"],
            "rows": 3,
            "fl": ["title"]
        }

        ```
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/YMALRequest'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProductToProductsResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /v1/qa/question_answering:
    post:
      tags:
        - Q&A APIs
      summary: Q&A API
      operationId: QaApIs_extractAnswer
      security:
        - Secret API Key: []
      description: >-
        Question Answering API analyzes each Product's `html` field and extracts
        paragraphs that can answer users'

        questions.


        For example, Miso can take question likes `What is python?`, and extract
        an answer like

        `Python is an interpreted, object-oriented, high-level programming
        language.` from a product's `html` field.


        Each answer is assigned a `probability` score that determines how likely
        a paragraph can accurately answer the

        question. A probability at least 0.7 is recommended, but you usually
        will need to fine-tune

        this threshold to find the precision-and-recall sweet-spot for your
        application.


        ### Limitations

        Miso will only extract answers from the `html` field and from products
        that have `enable_question_answering` set to `true`. Also,

        since Q&A is a much more complex search problem, the response time of
        this API is usually between 1 to 2 seconds

        for a new question. For an old question this API has answered before,
        the response time will be less than 75ms.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/QuestionAnsweringRequest'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QAResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /v1/qa/questions:
    post:
      tags:
        - Q&A APIs
      summary: Upload Question Bank API
      operationId: QaApIs_uploadQuestionBank
      security:
        - Secret API Key: []
      description: >-
        Question Bank API lets you upload your *question bank* to Miso. A
        *question bank* is a list of questions that

        can be used for **Question Autocomplete** and **Similar Question
        Search**.


        This API follows a *replace-all* model, i.e. a successful upload request
        will replace all the existing questions

        in the question bank.


        For example, the following request will replace the existing question
        bank with the given three questions:

        ```

        POST /v1/qa/questions

        {"data": [
            {"question": "What is python?"},
            {"question": "What is list comprehension?"},
            {"question": "How to sort a list in Python?"}
        ]}

        ```



            
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PostQuestionRequest'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BaseResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /v1/qa/question_autocomplete:
    post:
      tags:
        - Q&A APIs
      summary: Question Autocomplete API
      operationId: QaApIs_getAutocomplete
      security:
        - Secret API Key: []
      description: >-
        Question Autocomplete is an important feature for Q&A applications. It
        not only saves your users from typing

        the complete questions, but also showcases what questions your app is
        capable answering. This is important because

        Q&A is an advanced search feature that not every user is familar with.


        Miso generates autocomplete candidates from the question bank you
        uploaded (see [Question Bank Upload API](...)).

        Given a partial question string, Question Autocomplete API will suggest
        question candidates that match the query

        the user is typing.



        For example, let's first upload three questions to the question bank:

        ```

        POST /v1/qa/questions

        {"data": [
            {"question": "What is python?"},
            {"question": "What is pypy?"},
            {"question": "How to sort a list in Python?"}
        ]}

        ```


        Then, immediately after the above request finished, you can send the
        request below to get autocompletion

        candidates for any partial query string. For example, if the query
        string the user types so far is *"what is p"*:


        ```

        POST /v1/qa/question_autocomplete

        {
            "q": "what is p",
            "rows": 5
        }

        ```


        The API will respond the completion candidates like the following:

        ```

        {
            "data":
                "completions": [
                    {"question": "What is python?"},
                    {"question": "What is pypy?"}
                ]
            }
        }

        ```


        The API supports adaptive fuzzy matching such that even if there are
        typos in the query string, the API

        is still able to return the question candidates with the correct
        spellings. For example, if the query string is

        "*How to sorta*". The API is still able to match the completion
        candidate:

        "*How to sort a list in Python?*"


        The API is optimized for instant experience and has an average response
        time lower than 50ms.
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/QuestionAutocompleteRequest'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/QAAutocompleteResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
  /v1/bulk:
    post:
      tags:
        - Bulk API
      summary: Bulk Request API
      operationId: BulkApi_requestPost
      security:
        - Secret API Key: []
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/BulkRequest'
        required: true
      responses:
        '200':
          description: Successful Response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/BulkResponse'
        '422':
          description: Validation Error
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/HTTPValidationError'
components:
  schemas:
    AddToCart:
      title: add_to_cart
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            Used when a user adds a product into their shopping cart. This is a
            strong

            positive signal of the user's interest in the product, and may
            eventually lead to a purchase.
          enum:
            - add_to_cart
          type: string
        quantities:
          title: Quantities
          description: >

            The quantities of products the user adds to their cart or checks out
            with. This field should be a list of positive values.

            Specifically, if `product_ids` is a list of N products, the
            `quantities` needs to be a list with N numbers as well.

            If `quantities` are not specified, we will assume the quantity to be
            1 for every product.


            Example:

            ```

            {"quantities": [1, 2]}

            ```
          anyOf:
            - type: array
              items:
                type: number
            - type: number
          example:
            - 1
            - 2
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    AddToCollection:
      title: add_to_collection
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            Used when a user adds a product to their personal collection. This
            is a strong

            signal of their interest in the product.
          enum:
            - add_to_collection
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    AnchoringEntry:
      title: AnchoringEntry
      required:
        - product_id
        - anchor_ids
      type: object
      properties:
        product_id:
          title: Product Id
          description: Product to boost
          type: string
        anchor_ids:
          title: Anchor Ids
          description: A list of anchor products
          minLength: 1
          type: array
          items:
            type: string
            minLength: 1
        relative_position:
          title: Relative Position
          description: Relative position to the top anchor product
          type: integer
          default: -1
        start_time:
          title: Start Time
          description: When does the anchoring start. Leave it unset to start immediately
          type: string
          format: date-time
        end_time:
          title: End Time
          description: When will the anchoring end. Leave it unset to not have an end time
          type: string
          format: date-time
    Answer:
      title: Answer
      required:
        - probability
        - text
        - css_selector
      type: object
      properties:
        probability:
          title: Probability
          description: >-
            The probability this paragraph can sufficiently answer the user's
            question (from 0.0 to 1.0).
          maximum: 1
          minimum: 0
          type: number
        html:
          title: Html
          description: >-
            The answer paragraph in its original html tag, i.e. or the
            `outerHTML` of the
                                  answer paragraph node.
                                  
          type: string
        text:
          title: Text
          description: The plain text version of answer paragraph.
          type: string
        css_selector:
          title: Css Selector
          description: >

            The CSS selector that uniquely identifies the answer paragraph node
            in the original HTML content. This css selector

            matches exactly one HTML node that contains the answer paragraph. In
            order to be as unambiguous as possible,

            the returned CSS selector is in the form of a series of nth-child
            selectors starting from `:root` node

            (which is usually the `<html>`). For example,

            ```

            :root > div:nth-child(1) > p:nth-child(2)

            ```

            . This selector means the answer paragraph is a `<p>` tag that is
            the second child of a `<div>` node, which is in turn, the

            first child of the `:root` node.


            This CSS selector is useful when you want to make the answer
            paragraph stand out from the

            rest of the document. For example,

            the following JQuery code turns the background color of the answer
            paragraph to yellow:


            ```

            $(answer.css_selector).css("background-color", "yellow");

            ```
          type: string
    AnswerBlock:
      title: AnswerBlock
      required:
        - html
        - css_selector
        - relevant_children_slice
        - answer_css_selector
        - title
      type: object
      properties:
        title:
          title: Title
          description: >-
            The relevant title to the answer paragraph. This title is extracted
            from a header node close
                    to the answer paragraph. If there is no such node, the title will be an empty string
          type: string
        html:
          title: Html
          description: The HTML content of the answer block
          type: string
        css_selector:
          title: Css Selector
          description: >-
            The CSS selector that uniquely identifies the answer block from the
            HTML root
          type: string
        relevant_children_slice:
          title: Relevant Children Slice
          description: >-
            The range of children nodes inside the *answer block* that is
            relevant to the selected answer.
          type: array
          items:
            - type: integer
            - type: integer
        answer_css_selector:
          title: Answer Css Selector
          description: |2-

                    The CSS selector to the selected answer paragraph inside the answer block. You can use this selector to select
                    the answer from the answer block (as supposed to selecting from the HTML root)
                    
          type: string
    AnswerData:
      title: AnswerData
      required:
        - question
        - question_id
      type: object
      properties:
        question:
          title: Question
          description: The question given by the user
          type: string
        question_id:
          title: Question Id
          description: The UUID of the question for which the latest answer is requested.
          type: string
          format: uuid
        parent_question_id:
          title: Parent Question Id
          description: >-
            The UUID of the parent question if the current question is a
            follow-up to a previous question.
          type: string
          format: uuid
        answer_stage:
          title: Answer Stage
          description: The status of the answer generating process.
          type: string
          default: ''
        finished:
          title: Finished
          description: Whether the answer generating process is finished.
          type: boolean
          default: false
        answer:
          title: Answer
          description: The latest answer for the given question.
          type: string
          default: ''
        sources:
          title: Sources
          description: A list of sources related to the answer.
          type: array
          items:
            type: object
          default: []
        related_resources:
          title: Related Resources
          description: A list of related resources relevant to the question and answer.
          type: array
          items:
            type: object
          default: []
        followup_questions:
          title: Followup Questions
          description: A list of suggested follow-up questions.
          type: array
          items:
            type: string
        affiliation_products:
          title: Affiliation Products
          description: A list of suggested affiliation products.
          type: array
          items:
            type: object
    AttributeRecRecord:
      title: AttributeRecRecord
      required:
        - value
        - total
        - recommended_products
      type: object
      properties:
        value:
          title: Value
          description: The attribute we recommend to the user in their textual form.
          type: string
          example: Miso T-Shirt Shop
        total:
          title: Total
          description: The total number of products that have this attribute.
          type: integer
          example: 1000
        recommended_products:
          title: Recommended Products
          description: Top personalized recommendations of products have this attribute.
          type: array
          items:
            $ref: '#/components/schemas/Record'
          example: 1000
    AttributeRecResponse:
      title: AttributeRecResponse
      required:
        - data
      type: object
      properties:
        message:
          title: Message
          type: string
          default: success
        data:
          $ref: '#/components/schemas/AttributeResponseBody'
    AttributeResponseBody:
      title: AttributeResponseBody
      required:
        - attributes
      type: object
      properties:
        took:
          title: Took
          description: Number of milliseconds Miso took to retrieve the results.
          type: integer
          default: 0
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          default: 00000000-0000-0000-0000-000000000000
          example: 123e4567-e89b-12d3-a456-426614174000
        attributes:
          title: Attributes
          description: The attribute recommendation results.
          type: array
          items:
            $ref: '#/components/schemas/AttributeRecRecord'
    AutocompleteRequest:
      title: AutocompleteRequest
      required:
        - q
      type: object
      properties:
        engine_id:
          title: Engine Id
          description: >

            The engine you want to get results from. When you have more than one
            engine, you can use this parameter to

            specify the specific engine you want to get results from. If not
            specified, the default engine will be used.
          type: string
        user_id:
          title: User Id
          description: >

            The user who made the query and for whom Miso will personalize the
            results. For an anonymous visitor, use `anonymous_id` instead.
          type: string
        anonymous_id:
          title: Anonymous Id
          description: >-
            The anonymous visitor who made the query and for whom Miso will
            personalize the results. Either
                    `user_id` or `anonymous_id` needs to be specified for personalization to work. 
          type: string
        user_hash:
          title: User Hash
          description: >

            The hash of `user_id` (or `anonymous_id`) encrypted by your [Secret
            API Key](https://api.askmiso.com).

            `user_hash` is required to prevent unauthorized API access if you
            are

            making API calls with a [Publishable API
            Key](https://api.askmiso.com).


            You should generate the user_hash via HMAC scheme: you encrypt the
            desired user_id (or anonymous_id) with your

            [Secret API Key](https://api.askmiso.com) on your backend server,

            and then let the front-end code send the generated user_hash to Miso
            APIs to

            verify the identity of the API caller.


            As long as the [Secret API Key](https://api.askmiso.com)
             is kept secret, the user_hash prevents a malicious attacker from making unauthorized
            API calls or impersonating any of your users.


            Miso APIs accept the case-incentive "hex digest" of user hash, a
            sample Python 3 code to generate it on your backend server

            is as follow:


            ```python

            import hashlib

            import hmac


            YOUR_MISO_SECRET_API_KEY = "039c501ac8dfcac91"

            key_bytes = YOUR_MISO_SECRET_API_KEY.encode()

            user_id = "USER_123" # or anonymous_id

            user_id_bytes = user_id.encode()

            user_hash = hmac.new(
                key_bytes,
                user_id_bytes,
                hashlib.sha256).hexdigest()
            # user_hash is "7eb04da5e..."

            ```


            You can find more examples for other languages in this [Github
            Gist](https://gist.github.com/thewheat/7342c76ade46e7322c3e)
          type: string
        user_cohort:
          title: User Cohort
          description: >

            The user cohort you want to cold-start the recommendation with. For
            example, the following query will make

            recommendations based on the preferences of the users whose
            `country="United States"`, and `gender="Female"`

            in the User Profile dataset.

            ```

            {
                "user_cohort": {
                    "country": "United States",
                    "gender": "Female"
                }
            }

            ```
          type: object
          additionalProperties:
            anyOf:
              - type: boolean
              - type: string
        rows:
          title: Rows
          description: Number of search results to return.
          type: integer
          default: 5
        type:
          title: Type
          description: >

            The type of products to return. Use this parameter to make the API
            return only

            a certain type of products (see [Product
            APIs](https://api.askmiso.com)).


            This is particularly useful for sites that have multiple types of
            products:

            For example, on a marketplace site, YOu may model *merchandise* and
            *store* as two types of *products*. You can

            then use type parameter to limit the recommendation or search
            results to return only one kind of them.


            For instance, the following query will return only *store* products:
             ```
            {"type": "store"}
             ```

            For another example, on a travel website, you might have: *hotel*,
            *thing to do*, and *restaurant*,

            three kinds

            of products. You can use `type` parameter to limit results to one
            kind of them. For instance, the following

            query will limit the results to only *hotels* product:
             ```
            {"type": "hotel"}
             ```
          type: string
        dedupe_product_group_id:
          title: Dedupe Product Group Id
          description: >

            Whether to dedupe product based on `product_group_id`. If
            `dedupe_product_group_id=true`,

            Miso will prevent products with the same `product_group_id` from
            showing multiple

            times in the search or recommendation results.



            This is particular useful when one product has multiple variants
            (for example, different

            sizes, colors, or materials), and you only want to show this product
            only once in the search or recommendation

            results. Miso will then return the variant that is most likely to be
            of the user's interest.
          type: boolean
          default: true
        additional_interactions:
          title: Additional Interactions
          description: >

            A list of additional interaction records. You can use this fields to
            simulate user interactions without

            actually writing them to the interaction dataset.
          type: array
          items:
            anyOf:
              - $ref: '#/components/schemas/ProductDetailPageView'
              - $ref: '#/components/schemas/Search'
              - $ref: '#/components/schemas/AddToCart'
              - $ref: '#/components/schemas/RemoveFromCart'
              - $ref: '#/components/schemas/Checkout'
              - $ref: '#/components/schemas/Refund'
              - $ref: '#/components/schemas/Subscribe'
              - $ref: '#/components/schemas/AddToCollection'
              - $ref: '#/components/schemas/RemoveFromCollection'
              - $ref: '#/components/schemas/Read'
              - $ref: '#/components/schemas/Watch'
              - $ref: '#/components/schemas/Listen'
              - $ref: '#/components/schemas/Like'
              - $ref: '#/components/schemas/Dislike'
              - $ref: '#/components/schemas/Share'
              - $ref: '#/components/schemas/Rate'
              - $ref: '#/components/schemas/Bookmark'
              - $ref: '#/components/schemas/Complete'
              - $ref: '#/components/schemas/Feedback'
              - $ref: '#/components/schemas/Impression'
              - $ref: '#/components/schemas/ViewableImpression'
              - $ref: '#/components/schemas/Click'
              - $ref: '#/components/schemas/HomePageView'
              - $ref: '#/components/schemas/CategoryPageView'
              - $ref: '#/components/schemas/PromoPageView'
              - $ref: '#/components/schemas/ProductImageView'
              - $ref: '#/components/schemas/Custom'
          default: []
        fq:
          title: Fq
          description: >


            Defines a query in Solr syntax that can be used to restrict the
            superset of

            products to return, without influencing the overall ranking. `fq`
            can enable users to drill down to products

            with specific features based on different product attributes


            For example, the query below limits the search results to only show
            products whose size is either `M` or `S` and

            brand is `Nike`:


            ```

            {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

            ```


            You can use `fq` to apply filters against your custom attributes as
            well. For example, the query below limits the

            search results to only products whose `designer` attribute is
            `Calvin Klein`


            ```

            {"fq": "attributes.designer:\"Calvin Klein\""}

            ```


            `fq` can also limit search results by numerical range. For example,
            the following query limits the results to

            products that have `rating >= 4`.


            ```

            {"fq": "rating:[4 TO *]"}

            ```
          type: string
        boost_fq:
          title: Boost Fq
          description: >

            Defines a query in Solr syntax that can be used to boost a subset of
            products to the top of the ranking, or to

            specific *boost positions* (See `boost_positions` parameter below.)

            For example, the query below will promote all the relevant products
            whose brand is `Nike` to the top of

            recommendation list:


            ```

            {
                "boost_fq": "brand:\"Nike\""
            }

            ```


            For a slightly more complex example, the query below will promote
            the Nike products which have also been tagged

            as `ON SALE` to the top of the ranking:

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
            }

            ```

            It is worth mentioning that, Miso will only boost products that are
            relevant and have high likelihood to convert,

            and will not boost a low performance product only because it matches
            the boosting query.


            Depending on your boosting rules, in certain cases, you would like
            to prevent recommendation results from being

            too monotone due to boosting. With Miso, you have two tools to do
            so.


            First, you can specify `boost_positions` to place promoted products
            at specific positions in the ranking. For

            example, the query below will place boosted products only at the
            first and fourth places in the ranking

            (positions are 0-based), and place the remaining products in their
            original ranking, skipping these two positions.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "boost_positions": [0, 3]
            }

            ```


            The second tool is `diversification`. `diversification` parameter,
            on a best-effort basis, will try to

            maintain a minimum distance between products that have the same
            attributes. For example, the following query

            will place products made by the same brand apart from each other.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "diversification": {
                   "brand": {"minimum_distance": 1}
                }
            }

            ```
          type: string
        boost_positions:
          title: Boost Positions
          description: >

            Defines a list of 0-based positions you want to place the boosted
            products at.


            For example, the query below will promote products whose brand is
            `Nike` as the top and second recommendations:

            ```

            {
                "boost_fq": "brand:\"Nike\"",
                "boost_positions": [0, 1]
            }

            ```

            If `boost_positions` is not specified (which is the default
            behavior), all the boosted products will be ranked

            higher than the rest of the products.
          type: array
          items:
            type: integer
        boost_rules:
          title: Boost Rules
          description: >

            Define a list of boosting rules that will be applied to the search
            or recommendation results simultaneously. `boost_rules`

            parameter is particularly useful when you want to boost more than
            one sets of products, and promote each of them to different

            positions. For example, the query below will promote products whose
            brand is `Nike` to the top

            and second results, and products whose brand is `Adidas` to the
            third and fourth results:

            ```

            {
                "boost_rules": [
                    {
                        "boost_fq": "brand:\"Nike\"",
                        "boost_positions": [0, 1]
                    },
                    {
                        "boost_fq": "brand:\"Adidas\"",
                        "boost_positions": [2, 3]
                    }
                ]
            }

            ```
          type: array
          items:
            $ref: '#/components/schemas/BoostingFilterBase'
          default: []
        geo:
          $ref: '#/components/schemas/GeoQuery'
        q:
          title: Q
          description: >

            The search query users typed so far. Please keep the trailing spaces
            (if any) intact so that we

            know whether the user has finished typing the last word or is still
            typing it. For example, the following query

            means the user has finished typing the word *Fight*:

            ```

            {"q": "Fight "}

            ```

            On the other hand, the following query means the user has not
            finished typing the last word *Clu*:

            ```

            {"q": "Fight Clu"}

            ```
          minLength: 0
          type: string
        language:
          title: Language
          description: >

            Two-letter (639-1) language code of the search query. If given, the
            autocomplete results will be from

            that specific language. If not given, the autocomplete results will
            be from the primary language

            of the environment. Example query:

            ```

            {"language": "en"}

            ```
          type: string
        min_query_users:
          title: Min Query Users
          description: >

            Limits the query completion results to *historical queries* that
            have been made by at

            least this number of unique users. This parameter has no effect when
            `completion_fields` does not include

            `historical_queries`. We do not recommend setting `min_query_users`
            lower than 5. When

            `min_query_users` is too small, we might risk showing queries that
            contain typos or are too personal to the

            users who made the query.
          type: integer
          default: 5
        completion_fields:
          title: Completion Fields
          description: >+


            Controls the sources of autocompletion candidates. Miso performs
            autocompletion by matching

            what the user has typed so far to either the *title* of products or
            to other *attributes*.


            By default, we only autocomplete against the value in the `title`
            field. The `completion_fields` parameter lets you

            specify the attributes you want to perform autocompletion against.
            For example, the following

            query will limit the autocompletion candidates to the `title` and
            `tags` of products:


            ```

            {"completion_fields": ["title", "tags"]}

            ```


            Autocompletion also works on *custom attributes*. For example, if
            you have a custom attribute for the

            `designer_name` of the product, the following query limits
            autocompletion candidates to only the designer names:


            ```

            {"candidates": ["custom_attributes.designer_name"]}

            ```

          type: array
          items:
            type: string
          default:
            - title
        fl:
          title: Fl
          description: >

            List of fields to retrieve. For example, the following request
            retrieves only the `title` field of each product along

            with the `product_id`, which is always returned.


            ```

            {"fl": ["title"]}

            ```


            You can also match field names by using `*` as a wildcard. For
            example, the query below retrieves the `title`

            and any custom attributes under the `attributes` dictionary.


            ```

            {"fl": ["title", "attributes.*"]}

            ```


            The following retrieves all the available fields:


            ```

            {"fl": ["*"]}

            ```


            For the lowest latency, use an empty array to retrieve just the
            `product_id` field (which is the default).

            ```

            {"fl": []}

            ```
          type: array
          items:
            type: string
          default: []
      x-konfig-properties:
        geo:
          title: Geo
          description: >

            When set, filter result to include only products within certain
            geographic range from given point will be returned,

            or to boost product within the same range.


            Product should have a field that holds the location of the product,
            `location` is used by default,

            but other field can also be used.


            Distance can be in miles or kilometers. If `distance_unit` is not
            set, `mile` will be used.


            For example, to limit results to products within 100 miles of New
            York city:

            ```

            {
                "geo": {
                    "filter": [{
                        "lat": 40.73061,
                        "lon": -73.93524,
                        "distance": 100
                    }]
                }
            }

            ```


            To boost products within 2 kilometers around Alcatraz Island
            according to `loc` field:

            ```

            {
                "geo": {
                    "boost": [{
                        "field": "loc",
                        "lat": 37.82667,
                        "lon": -122.42278,
                        "distance": 2,
                        "distance_unit": "km"
                    }]
                }
            }

            ```
    AutocompleteResponse:
      title: AutocompleteResponse
      required:
        - data
      type: object
      properties:
        message:
          title: Message
          type: string
          default: success
        data:
          $ref: '#/components/schemas/AutocompleteResponseBody'
    AutocompleteResponseBody:
      title: AutocompleteResponseBody
      description: |-
        autocomplete api response body:
        {
         "completions": [{"text": "", "source": ""}]
        }
      required:
        - completions
      type: object
      properties:
        took:
          title: Took
          description: Number of milliseconds Miso took to retrieve the results.
          type: integer
          default: 0
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          default: 00000000-0000-0000-0000-000000000000
          example: 123e4567-e89b-12d3-a456-426614174000
        completions:
          title: Completions
          description: Autocompletion results.
          type: object
          additionalProperties:
            type: array
            items:
              anyOf:
                - $ref: '#/components/schemas/TitleCompletion'
                - $ref: '#/components/schemas/Completion'
          example:
            title:
              - text: Miso Japanese Shiba Inu Dog Eating Miso Soup T-Shirt
                type: title
                product:
                  product_id: 123ABC-S-Black
            brand:
              - text: Miso
                type: brand
              - text: Mitsui
                type: brand
    BaseBody:
      title: BaseBody
      type: object
      properties:
        took:
          title: Took
          description: Number of milliseconds Miso took to retrieve the results.
          type: integer
          default: 0
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          default: 00000000-0000-0000-0000-000000000000
          example: 123e4567-e89b-12d3-a456-426614174000
    BaseGeo:
      title: BaseGeo
      required:
        - lat
        - lon
      type: object
      properties:
        lat:
          title: Lat
          description: Latitude of the center point, should between 90 and -90
          maximum: 90
          minimum: -90
          type: number
        lon:
          title: Lon
          description: Longitude of the center point, should between 180 and -180
          maximum: 180
          minimum: -180
          type: number
    BaseResponse:
      title: BaseResponse
      required:
        - data
      type: object
      properties:
        message:
          title: Message
          type: string
          default: success
        data:
          $ref: '#/components/schemas/BaseBody'
    BaseResponseBody:
      title: BaseResponseBody
      required:
        - products
      type: object
      properties:
        took:
          title: Took
          description: Number of milliseconds Miso took to retrieve the results.
          type: integer
          default: 0
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          default: 00000000-0000-0000-0000-000000000000
          example: 123e4567-e89b-12d3-a456-426614174000
        products:
          title: Products
          description: The recommendation results.
          type: array
          items:
            $ref: '#/components/schemas/Record'
    Bookmark:
      title: bookmark
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: |

            Used when a user bookmarks a product.
          enum:
            - bookmark
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    BoostItem:
      title: BoostItem
      required:
        - field
        - option
        - query
      type: object
      properties:
        field:
          title: Field
          description: The boosting field of the rule.
          type: string
        option:
          title: Option
          description: The boosting option of the field.
          enum:
            - contains
            - not_contain
            - is
            - is_not
          type: string
        query:
          title: Query
          description: The boosting query of the field.
          type: string
        action:
          title: Action
          description: The boosting action of the field.
          enum:
            - pin
            - bury
            - remove
          type: string
        pin_position:
          title: Pin Position
          description: >-
            This field is a 1-based integer to describe the position. This field
            is only used when action is "pin".
          minimum: 1
          exclusiveMinimum: 0
          type: integer
          example: 1
      example:
        field: title
        option: contains
        query: iphone
    BoostingFilterBase:
      title: BoostingFilterBase
      type: object
      properties:
        boost_fq:
          title: Boost Fq
          description: >

            Defines a query in Solr syntax that can be used to boost a subset of
            products to the top of the ranking, or to

            specific *boost positions* (See `boost_positions` parameter below.)

            For example, the query below will promote all the relevant products
            whose brand is `Nike` to the top of

            recommendation list:


            ```

            {
                "boost_fq": "brand:\"Nike\""
            }

            ```


            For a slightly more complex example, the query below will promote
            the Nike products which have also been tagged

            as `ON SALE` to the top of the ranking:

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
            }

            ```

            It is worth mentioning that, Miso will only boost products that are
            relevant and have high likelihood to convert,

            and will not boost a low performance product only because it matches
            the boosting query.


            Depending on your boosting rules, in certain cases, you would like
            to prevent recommendation results from being

            too monotone due to boosting. With Miso, you have two tools to do
            so.


            First, you can specify `boost_positions` to place promoted products
            at specific positions in the ranking. For

            example, the query below will place boosted products only at the
            first and fourth places in the ranking

            (positions are 0-based), and place the remaining products in their
            original ranking, skipping these two positions.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "boost_positions": [0, 3]
            }

            ```


            The second tool is `diversification`. `diversification` parameter,
            on a best-effort basis, will try to

            maintain a minimum distance between products that have the same
            attributes. For example, the following query

            will place products made by the same brand apart from each other.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "diversification": {
                   "brand": {"minimum_distance": 1}
                }
            }

            ```
          type: string
        boost_positions:
          title: Boost Positions
          description: >

            Defines a list of 0-based positions you want to place the boosted
            products at.


            For example, the query below will promote products whose brand is
            `Nike` as the top and second recommendations:

            ```

            {
                "boost_fq": "brand:\"Nike\"",
                "boost_positions": [0, 1]
            }

            ```

            If `boost_positions` is not specified (which is the default
            behavior), all the boosted products will be ranked

            higher than the rest of the products.
          type: array
          items:
            type: integer
    BulkIndividualResponse:
      title: BulkIndividualResponse
      description: 'Individual response in a bulk API request '
      required:
        - error
        - status_code
        - body
      type: object
      properties:
        error:
          title: Error
          description: Whether there is an error
          type: boolean
        status_code:
          title: Status Code
          description: Status code of the response
          type: integer
        body:
          $ref: '#/components/schemas/GeneralBody'
      x-konfig-properties:
        body:
          title: Body
          description: The response body
    BulkRequest:
      title: BulkRequest
      description: Bulk API request
      required:
        - requests
      type: object
      properties:
        requests:
          title: Requests
          description: An array of request objects
          maxItems: 100
          minItems: 1
          type: array
          items:
            $ref: '#/components/schemas/EngineAPIRequest'
    BulkResponse:
      title: BulkResponse
      description: 'Bulk API response '
      required:
        - data
        - errors
      type: object
      properties:
        data:
          title: Data
          description: The bulk request results
          type: array
          items:
            $ref: '#/components/schemas/BulkIndividualResponse'
        errors:
          title: Errors
          description: Whether there is any errors in the responses
          type: boolean
    Campaign:
      title: Campaign
      type: object
      properties:
        name:
          title: Name
          description: >-
            Name of the campaign. Identifies a specific product promotion or
            strategic campaign.  (see [UTM
            parameters](https://en.wikipedia.org/wiki/UTM_parameters))
          type: string
          example: spring_sale
        source:
          title: Source
          description: >-
            Source of the campaign. Identifies which site sent the traffic. (see
            [UTM parameters](https://en.wikipedia.org/wiki/UTM_parameters))
          type: string
          example: Google
        medium:
          title: Medium
          description: >-
            Medium of the campaign that identifies what type of link was used,
            such as cost per click or email. (see [UTM
            parameters](https://en.wikipedia.org/wiki/UTM_parameters))
          type: string
          example: cpc
        term:
          title: Term
          description: >-
            Term of the campaign that identifies search terms. (see [UTM
            parameters](https://en.wikipedia.org/wiki/UTM_parameters))
          type: string
          example: running+shoes
        content:
          title: Content
          description: >-
            Content of the campaign that identifies what specifically was
            clicked to bring the user to the site, such as a banner ad or a text
            link. It is often used for A/B testing and content-targeted ads.
            Identifies search terms.  (see [UTM
            parameters](https://en.wikipedia.org/wiki/UTM_parameters))
          type: string
          example: textlink
    CategoryPageView:
      title: category_page_view
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            Used when a user views a category page for a specific “family” or
            “group” or products or content.

            This is a strong indicator of what types category of products or
            content the user is interested in.
          enum:
            - category_page_view
          type: string
        duration:
          title: Duration
          description: >

            How long (in seconds) the user stayed on this page, or consumed
            (listened, read, or watched) a product. This field is

            optional, but it's very important in scenarios where consumption
            duration matters, including

            `product_detail_page_view`, `category_page_view`, `watch`, `listen`,
            and `read`. For example, if a user only

            views or consumes a product for less than 5 seconds, that user is
            probably not interested in the product. On

            the other hand, if a user stays on a page for a while, it usually
            means they are seriously engaging with or

            considering the product. When `duration` is absent, we will use the
            timestamp of the next interaction to

            infer a rough duration value.


            Example:

            ```

            {"duration": 61.5}

            ```
          type: number
          example: 61.5
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
        category:
          title: Category
          description: >

            Categories usually fall in a hierarchy, such as *Home & Garden >
            Kitchen & Dining > Kitchen Tools & Utensils >

            Sushi Mats* Use this field to specify the full hierarchical list
            describing the category the user is viewing.


            The levels should be listed from broad to narrow:

            `["TOP_LEVEL_CATEGORY", "SUBCATEGORY_1", "SUBCATEGORY_2", ...]`.

            This field is only used by the category_page_view interaction type,
            but this data is very useful for

            determining the user’s interests.

            Example:

            ```

            [
             "Home & Garden",            // TOP_LEVEL_CATEGORY
             "Kitchen & Dining",         // SUBCATEGORY_1
             "Kitchen Tools & Utensils", // SUBCATEGORY_2
             "Sushi Mats"                // SUBCATEGORY_3
            ]

            ```
          type: array
          items:
            type: string
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    CategoryRecRecord:
      title: CategoryRecRecord
      required:
        - category
        - total
        - recommended_products
      type: object
      properties:
        category:
          title: Category
          description: The attribute we recommend to the user in their textual form
          type: array
          items:
            type: string
          example:
            - Miso T-Shirt Shop
        total:
          title: Total
          description: The total number of products that are associated with this category.
          type: integer
          example: 1000
        recommended_products:
          title: Recommended Products
          description: >-
            Top personalized recommendations for the user of products that are
            associated with this category.
          type: array
          items:
            $ref: '#/components/schemas/Record'
          example: 1000
    CategoryRecResponse:
      title: CategoryRecResponse
      required:
        - data
      type: object
      properties:
        message:
          title: Message
          type: string
          default: success
        data:
          $ref: '#/components/schemas/CategoryResponseBody'
    CategoryResponseBody:
      title: CategoryResponseBody
      required:
        - categories
      type: object
      properties:
        took:
          title: Took
          description: Number of milliseconds Miso took to retrieve the results.
          type: integer
          default: 0
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          default: 00000000-0000-0000-0000-000000000000
          example: 123e4567-e89b-12d3-a456-426614174000
        categories:
          title: Categories
          description: The category recommendation results.
          type: array
          items:
            $ref: '#/components/schemas/CategoryRecRecord'
    CheckProductExistence:
      title: CheckProductExistence
      required:
        - product_ids
      type: object
      properties:
        product_ids:
          title: Product Ids
          description: >-
            A list of product ids to be checked if they will be returned in the
            search results
          minLength: 1
          type: array
          items:
            type: string
            minLength: 1
    Checkout:
      title: checkout
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            Used when a user enters checks out with a set of products. For an
            eCommerce site, this is the strongest signal of the user's

            interest and has a high probability of leading to an eventual
            purchase.
          enum:
            - checkout
          type: string
        revenue:
          title: Revenue
          description: >

            Total revenue associated with the checkout.  The revenue should
            include generally shipping, tax, etc. that you

            want to include as part of your revenue calculations.
          type: number
          example: 23.32
        quantities:
          title: Quantities
          description: >

            The quantities of products the user adds to their cart or checks out
            with. This field should be a list of positive values.

            Specifically, if `product_ids` is a list of N products, the
            `quantities` needs to be a list with N numbers as well.

            If `quantities` are not specified, we will assume the quantity to be
            1 for every product.


            Example:

            ```

            {"quantities": [1, 2]}

            ```
          anyOf:
            - type: array
              items:
                type: number
            - type: number
          example:
            - 1
            - 2
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    ChildrenObject:
      title: ChildrenObject
      required:
        - id
      type: object
      properties:
        title:
          title: Title
          type: string
        description:
          title: Description
          type: string
        id:
          title: Id
          type: string
        url:
          title: Url
          type: string
        html:
          title: Html
          type: string
        headers:
          title: Headers
          type: array
          items:
            type: string
        custom_attributes:
          title: Custom Attributes
          type: object
          additionalProperties:
            anyOf:
              - type: boolean
              - type: integer
              - type: number
              - type: string
              - type: array
                items:
                  type: number
              - type: array
                items:
                  type: string
              - type: object
                additionalProperties:
                  anyOf:
                    - type: string
                    - type: number
                    - type: integer
                    - type: boolean
              - type: array
                items:
                  type: object
                  additionalProperties:
                    anyOf:
                      - type: string
                      - type: number
                      - type: integer
                      - type: boolean
    Click:
      title: click
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            Used when user clicked on something, and does not belong to any
            other interaction type.
          enum:
            - click
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    Complete:
      title: complete
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            Used when a user "complete" a product (e.g. complete a course or a
            video).
          enum:
            - complete
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    Completion:
      title: Completion
      description: 'basic completion response only has `text` '
      required:
        - text
        - text_with_markups
        - text_with_inverted_markups
      type: object
      properties:
        text:
          title: Text
          minLength: 1
          type: string
          example: Japanese Shiba Inu Dog Eating Miso Soup T-Shirt
        text_with_markups:
          title: Text With Markups
          minLength: 1
          type: string
          example: Japanese<mark> Shiba Inu Dog Eating Miso Soup T-Shirt</mark>
        text_with_inverted_markups:
          title: Text With Inverted Markups
          minLength: 1
          type: string
          example: <mark>Japanese</mark> Shiba Inu Dog Eating Miso Soup T-Shirt
    CreateResponse:
      title: CreateResponse
      required:
        - message
        - data
      type: object
      properties:
        message:
          title: Message
          description: Human-readable message
          type: string
          example: success
        data:
          $ref: '#/components/schemas/TaskId'
    Custom:
      title: custom
      required:
        - type
        - custom_action_name
      type: object
      properties:
        type:
          title: Type
          description: >

            Used when you want to record any other kinds of interactions between
            users and products.
          enum:
            - custom
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
        custom_action_name:
          title: Custom Action Name
          description: |

            The name of the custom interaction that you have defined.
          type: string
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    DeleteResponse:
      title: DeleteResponse
      required:
        - message
        - data
      type: object
      properties:
        message:
          title: Message
          description: Human-readable message
          type: string
          example: success
        data:
          $ref: '#/components/schemas/TaskId'
    Dislike:
      title: dislike
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            Used when a user indicates a `dislike` for a product or indicates

            they would like to not be recommended content or products like this
            in the future.
          enum:
            - dislike
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    DiversifyField:
      title: DiversifyField
      type: object
      properties:
        minimum_distance:
          title: Minimum Distance
          description: Minimum distance between two products that have the same value
          type: integer
          default: 1
        always_together:
          title: Always Together
          description: >-
            If always_together=true, all the products that have the same value
            for this field, will be put side-by-side.
          type: boolean
          default: false
    EngineAPIRequest:
      title: EngineAPIRequest
      description: Engine API request
      required:
        - api_name
        - body
      type: object
      properties:
        api_name:
          title: Api Name
          description: >

            The name of the API. An API name should contain one slash. For
            example: `search/search` or `recommendation/user_to_products`
          type: string
        body:
          title: Body
          description: |

            The request body to the API.
          type: object
    ExperimentRequest:
      title: ExperimentRequest
      type: object
      properties:
        user_id:
          title: User Id
          description: Identifies the signed-in user who performed the interaction.
          type: string
          example: '2179873'
        anonymous_id:
          title: Anonymous Id
          description: A pseudo-unique substitute for the User Id
          type: string
          example: 403fb18e-98ff-434d-8585-726fabf5ed37
        variant_name:
          title: Variant Name
          description: >-
            Set the variant_name if you want to assign a user to a specific
            variant. Most of the time, you don't need to pass this field.
            Instead, the system will automatically assign a variant for this
            user.
          type: string
          example: Treatment_Group
        timestamp:
          title: Timestamp
          description: >-
            The time the user is assigned to the variant group. If not set,
            current time will be used.
          type: string
          format: date-time
          example: '2022-01-23T12:34:56-08:00'
    FacetCounts:
      title: FacetCounts
      type: object
      properties:
        facet_fields:
          title: Facet Fields
          description: Facet counts of each facet field
          type: object
          additionalProperties:
            type: array
            items:
              type: array
              items:
                - type: string
                - type: integer
          default: {}
    FacetDefinition:
      title: FacetDefinition
      required:
        - field
      type: object
      properties:
        field:
          title: Field
          description: >+

            The field name to create a facet against. For example, the following
            query will create a facet against

            the `custom_attributes.director` field, and return the ten most
            common facet values of this field

            (for Products that match the search query):

            ```

            {
                "field": "custom_attributes.director",
                "size": 10
            }

            ```

          type: string
        size:
          title: Size
          description: >

            Number of facet values to return. The facet values are sort
            descendingly by the number of Products

            that have these values (and match the search query).
          type: integer
          default: 10
        include:
          title: Include
          description: >

            Filter facet values based on a regular expression. For example, the
            following query will return only the facet

            values that start with `Steven` (case-sensitive):

            ```

            {
                "field": "custom_attributes.director",
                "size": 10,
                "include": "Steven.*"
            }

            ```

            You can escape a special character with a preceding backslash `\` or
            surround it with double quotes.

            For example, the following query will only return the facet values
            starting with `St.`:


            ```

            {
                "field": "custom_attributes.place_name",
                "size": 10,
                "include": "\"St.\".*"
            }

            ```


            Note that, the `include` parameter will only affect the facet
            values, and will not affect the search result itself.
          type: string
        ranges:
          title: Ranges
          description: >

            Facet ranges for numeric fields or date-like string fields. For
            example, the following query groups the products

            into fours buckets against on their `original_price` ranges, each of
            which has a user-friendly "key":

            ```

            {
                "field": "original_price",
                "ranges": [
                    {"to": 10, "key": "Less than 10 dollars"},
                    {"from": 10, "to": 100, "key": "10 to 100 dollars"},
                    {"from": 100, "to": 1000, "key": "100 to 1,000 dollars"},
                    {"from": 1000, "key": "More than 1,000 dollars"}
                ]
            }

            ```


            For each range object, you need to at least specify one of the `to`
            or `from` values (or both). `from`

            is always **inclusive**, and `to` is always **exclusive**. In the
            response, Miso refers to each bucket by their `key`.

            For example, the above request will have the following response:

            ```

            {
              "facet_counts": {
                "facet_fields": {
                  "original_price": [
                    [
                      "Less than 10 dollars", 1987
                    ],
                    [
                      "10 to 100 dollars", 109
                    ],
                    [
                      "100 to 1,000 dollars", 123
                    ],
                    [
                      "More than 1,000 dollars", 5
                    ]
                  ]
                }
              }
            }

            ```
          type: array
          items:
            $ref: '#/components/schemas/RangeRequireKey'
        queries:
          title: Queries
          description: >

            Facet queries that support facet counts for any arbitrary Lucene
            queries,

            each of which is labeled by a user-friendly "key":

            ```

            {
                "field": "my_custom_facet",
                "queries": [
                    {
                        "query": "price: [* TO 10] AND size:"Small"",
                        "key": "Less than 10 dollars / Small size"
                    },
                    {
                        "query": "price: [10 TO 100] AND size:"Medium"",
                        "key": "10 to 100 dollars / Medium size"
                    },
                    {
                        "query": "price: [100 TO *] AND size:"Large"",
                        "key": "More than 100 dollars / Large size"
                    }
                ]
            }

            ```


            In the response, Miso refers to the query result by their `key`.

            For example, the above request will have the following response:

            ```

            {
              "facet_counts": {
                "facet_fields": {
                  "my_custom_facet": [
                    [
                      "Less than 10 dollars / Small size", 1987
                    ],
                    [
                      "10 to 100 dollars / Medium size", 109
                    ],
                    [
                      "More than 100 dollars / Large size", 123
                    ]
                  ]
                }
              }
            }

            ```
          type: array
          items:
            $ref: '#/components/schemas/QueryFilterRequireKey'
    Feedback:
      title: feedback
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: |

            Used when a user sends feedback on provided results.
          enum:
            - feedback
          type: string
        question_id:
          title: Question Id
          description: >

            A unique identifier representing the specific question for which
            feedback is being provided.
          maxLength: 512
          type: string
          example: question_123
        result_type:
          title: Result Type
          description: >

            Indicates the type of result the provided feedback is associated
            with, e.g., an answer or a suggestion.
          type: string
          example: answer
        value:
          title: Value
          description: >

            Specifies the user's perspective on the provided result, with
            possible values being helpful, not helpful,

            or unselected if the user has not provided any feedback.
          type: string
          example: helpful
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    Filter:
      title: Filter
      type: object
      properties:
        terms:
          title: Terms
          type: array
          items:
            type: string
        ranges:
          title: Ranges
          type: array
          items:
            $ref: '#/components/schemas/Range'
        queries:
          title: Queries
          type: array
          items:
            $ref: '#/components/schemas/QueryFilter'
    FilterQueryItem:
      title: FilterQueryItem
      required:
        - option
        - query
      type: object
      properties:
        option:
          title: Option
          description: The filter query option of the boosting rule.
          enum:
            - overlap_with
          type: string
        query:
          title: Query
          description: The filter query of the boosting rule.
          type: string
    GeneralBody:
      title: GeneralBody
      description: 'Allow any json body '
      type: object
      properties: {}
    GeoDistanceQuery:
      title: GeoDistanceQuery
      required:
        - lat
        - lon
        - distance
      type: object
      properties:
        lat:
          title: Lat
          description: Latitude of the center point, should between 90 and -90
          maximum: 90
          minimum: -90
          type: number
        lon:
          title: Lon
          description: Longitude of the center point, should between 180 and -180
          maximum: 180
          minimum: -180
          type: number
        field:
          title: Field
          description: >-
            Name of the field in product data that holds geographic coordinate.
            Defaults to `location`
          type: string
          default: location
        distance:
          title: Distance
          description: >-
            Distance to center point, in kilometer or mile (according to
            `distance_unit`)
          type: number
        distance_unit:
          title: Distance Unit
          description: Unit of distance(`km` or `mile`). Defaults to `mile`
          enum:
            - km
            - mile
          default: mile
          type: string
    GeoDistanceQueryBoost:
      title: GeoDistanceQueryBoost
      required:
        - lat
        - lon
        - distance
      type: object
      properties:
        lat:
          title: Lat
          description: Latitude of the center point, should between 90 and -90
          maximum: 90
          minimum: -90
          type: number
        lon:
          title: Lon
          description: Longitude of the center point, should between 180 and -180
          maximum: 180
          minimum: -180
          type: number
        field:
          title: Field
          description: >-
            Name of the field in product data that holds geographic coordinate.
            Defaults to `location`
          type: string
          default: location
        distance:
          title: Distance
          description: >-
            Distance to center point, in kilometer or mile (according to
            `distance_unit`)
          type: number
        distance_unit:
          title: Distance Unit
          description: Unit of distance(`km` or `mile`). Defaults to `mile`
          enum:
            - km
            - mile
          default: mile
          type: string
        boost_positions:
          title: Boost Positions
          description: |2-

                    Defines a list of 0-based positions you want to place the boosted products at.

                    If `boost_positions` is not specified (which is the default behavior), all the boosted products will be ranked
                    higher than the rest of the products.
                    
          type: array
          items:
            type: integer
    GeoQuery:
      title: GeoQuery
      type: object
      properties:
        filter:
          title: Filter
          description: >-
            When set, filter result to include only products within certain
            geographic range from given point.
          type: array
          items:
            $ref: '#/components/schemas/GeoDistanceQuery'
          default: []
        boost:
          title: Boost
          description: >-
            When set, boost products within certain geographic range from given
            point.
          type: array
          items:
            $ref: '#/components/schemas/GeoDistanceQueryBoost'
          default: []
    HTTPValidationError:
      title: HTTPValidationError
      type: object
      properties:
        detail:
          title: Detail
          type: array
          items:
            $ref: '#/components/schemas/ValidationError'
    HomePageView:
      title: home_page_view
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: |

            Used when a user views your home page.
          enum:
            - home_page_view
          type: string
        duration:
          title: Duration
          description: >

            How long (in seconds) the user stayed on this page, or consumed
            (listened, read, or watched) a product. This field is

            optional, but it's very important in scenarios where consumption
            duration matters, including

            `product_detail_page_view`, `category_page_view`, `watch`, `listen`,
            and `read`. For example, if a user only

            views or consumes a product for less than 5 seconds, that user is
            probably not interested in the product. On

            the other hand, if a user stays on a page for a while, it usually
            means they are seriously engaging with or

            considering the product. When `duration` is absent, we will use the
            timestamp of the next interaction to

            infer a rough duration value.


            Example:

            ```

            {"duration": 61.5}

            ```
          type: number
          example: 61.5
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    Impression:
      title: impression
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >-

            Used to record when a user saw or was presented with a product or
            content asset.

            An impression does not mean a user is interested: for example, if
            there is an impression for a

            certain product, but no further interaction occurs with that
            product, we assume the user is probably not

            interested in it.


            For an impression that was generated by Miso's search results or
            recommendations results, it is important to

            include the `miso_id` associated with the results so that we know
            the impression is from Miso
          enum:
            - impression
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    InteractionBulkIn:
      title: InteractionBulkIn
      required:
        - data
      type: object
      properties:
        data:
          title: Data
          type: array
          items:
            anyOf:
              - $ref: '#/components/schemas/ProductDetailPageView'
              - $ref: '#/components/schemas/Search'
              - $ref: '#/components/schemas/AddToCart'
              - $ref: '#/components/schemas/RemoveFromCart'
              - $ref: '#/components/schemas/Checkout'
              - $ref: '#/components/schemas/Refund'
              - $ref: '#/components/schemas/Subscribe'
              - $ref: '#/components/schemas/AddToCollection'
              - $ref: '#/components/schemas/RemoveFromCollection'
              - $ref: '#/components/schemas/Read'
              - $ref: '#/components/schemas/Watch'
              - $ref: '#/components/schemas/Listen'
              - $ref: '#/components/schemas/Like'
              - $ref: '#/components/schemas/Dislike'
              - $ref: '#/components/schemas/Share'
              - $ref: '#/components/schemas/Rate'
              - $ref: '#/components/schemas/Bookmark'
              - $ref: '#/components/schemas/Complete'
              - $ref: '#/components/schemas/Feedback'
              - $ref: '#/components/schemas/Impression'
              - $ref: '#/components/schemas/ViewableImpression'
              - $ref: '#/components/schemas/Click'
              - $ref: '#/components/schemas/HomePageView'
              - $ref: '#/components/schemas/CategoryPageView'
              - $ref: '#/components/schemas/PromoPageView'
              - $ref: '#/components/schemas/ProductImageView'
              - $ref: '#/components/schemas/Custom'
    InteractionCreateOut:
      title: InteractionCreateOut
      required:
        - message
      type: object
      properties:
        message:
          title: Message
          description: Human-readable message
          type: string
          example: success
    InteractionDeleteIn:
      title: InteractionDeleteIn
      required:
        - user_ids
      type: object
      properties:
        user_ids:
          title: User Ids
          type: array
          items:
            type: string
    InteractionDeleteOut:
      title: InteractionDeleteOut
      required:
        - message
      type: object
      properties:
        message:
          title: Message
          description: Human-readable message
          type: string
          example: success
    Like:
      title: like
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: |

            Used to record when a user indicates a `like` for a product.
          enum:
            - like
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    Listen:
      title: listen
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            Used to record when and for how long a user listens to content that
            is of an audio format.
          enum:
            - listen
          type: string
        duration:
          title: Duration
          description: >

            How long (in seconds) the user stayed on this page, or consumed
            (listened, read, or watched) a product. This field is

            optional, but it's very important in scenarios where consumption
            duration matters, including

            `product_detail_page_view`, `category_page_view`, `watch`, `listen`,
            and `read`. For example, if a user only

            views or consumes a product for less than 5 seconds, that user is
            probably not interested in the product. On

            the other hand, if a user stays on a page for a while, it usually
            means they are seriously engaging with or

            considering the product. When `duration` is absent, we will use the
            timestamp of the next interaction to

            infer a rough duration value.


            Example:

            ```

            {"duration": 61.5}

            ```
          type: number
          example: 61.5
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    LocationInformation:
      title: LocationInformation
      required:
        - lat
        - lon
      type: object
      properties:
        lat:
          title: Lat
          type: number
          example: 40.74844
        lon:
          title: Lon
          type: number
          example: -73.985664
    MultipleGetRequest:
      title: MultipleGetRequest
      required:
        - product_ids
      type: object
      properties:
        engine_id:
          title: Engine Id
          description: >

            The engine you want to get results from. When you have more than one
            engine, you can use this parameter to

            specify the specific engine you want to get results from. If not
            specified, the default engine will be used.
          type: string
        user_id:
          title: User Id
          description: >

            The user who made the query and for whom Miso will personalize the
            results. For an anonymous visitor, use `anonymous_id` instead.
          type: string
        anonymous_id:
          title: Anonymous Id
          description: >-
            The anonymous visitor who made the query and for whom Miso will
            personalize the results. Either
                    `user_id` or `anonymous_id` needs to be specified for personalization to work. 
          type: string
        user_hash:
          title: User Hash
          description: >

            The hash of `user_id` (or `anonymous_id`) encrypted by your [Secret
            API Key](https://api.askmiso.com).

            `user_hash` is required to prevent unauthorized API access if you
            are

            making API calls with a [Publishable API
            Key](https://api.askmiso.com).


            You should generate the user_hash via HMAC scheme: you encrypt the
            desired user_id (or anonymous_id) with your

            [Secret API Key](https://api.askmiso.com) on your backend server,

            and then let the front-end code send the generated user_hash to Miso
            APIs to

            verify the identity of the API caller.


            As long as the [Secret API Key](https://api.askmiso.com)
             is kept secret, the user_hash prevents a malicious attacker from making unauthorized
            API calls or impersonating any of your users.


            Miso APIs accept the case-incentive "hex digest" of user hash, a
            sample Python 3 code to generate it on your backend server

            is as follow:


            ```python

            import hashlib

            import hmac


            YOUR_MISO_SECRET_API_KEY = "039c501ac8dfcac91"

            key_bytes = YOUR_MISO_SECRET_API_KEY.encode()

            user_id = "USER_123" # or anonymous_id

            user_id_bytes = user_id.encode()

            user_hash = hmac.new(
                key_bytes,
                user_id_bytes,
                hashlib.sha256).hexdigest()
            # user_hash is "7eb04da5e..."

            ```


            You can find more examples for other languages in this [Github
            Gist](https://gist.github.com/thewheat/7342c76ade46e7322c3e)
          type: string
        product_ids:
          title: Product Ids
          description: >

            List of product_ids to retrieve. Products will be returned in the
            same order as they are given in this list.
          type: array
          items:
            type: string
        fl:
          title: Fl
          description: >

            List of fields to retrieve. For example, the following request
            retrieves only the `title` field of each product
             along with the `product_id`, which is always returned.

            ```

            {"fl": ["title"]}

            ```


            You can also match field names by using `*` as a wildcard. For
            example, the query below retrieves the `title`

            and any custom attributes under the `attributes` dictionary.


            ```

            {"fl": ["title", "attributes.*"]}

            ```


            The following retrieves all the available fields  (which is the
            default):


            ```

            {"fl": ["*"]}

            ```


            For the lowest latency, use an empty array to retrieve just the
            `product_id` field.

            ```

            {"fl": []}

            ```
          type: array
          items:
            type: string
          default:
            - '*'
    MultipleGetResponse:
      title: MultipleGetResponse
      required:
        - data
      type: object
      properties:
        message:
          title: Message
          type: string
          default: success
        data:
          $ref: '#/components/schemas/MultipleGetResponseBody'
    MultipleGetResponseBody:
      title: MultipleGetResponseBody
      description: >-
        Return a list of Product records. Some or all of them are potentially
        not found
      required:
        - products
      type: object
      properties:
        took:
          title: Took
          description: Number of milliseconds Miso took to retrieve the results.
          type: integer
          default: 0
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          default: 00000000-0000-0000-0000-000000000000
          example: 123e4567-e89b-12d3-a456-426614174000
        products:
          title: Products
          type: array
          items:
            $ref: '#/components/schemas/RecordWithFound'
    OrderByDefinition:
      title: OrderByDefinition
      required:
        - field
      type: object
      properties:
        field:
          title: Field
          description: >+

            Name of the field to order by. You can sort by any numeric and
            boolean fields in your Product catalog, or use one of any special
             fields:
            * **_personalization_score**: the score that rates the degree of
            affinity between

            a pair of user and product from Miso's personalization algorithm.

            * **_search_score**: the score that rates the degree of search
            keyword matches to a product's catalog.

            * **_boosting_score**: the score that rates the degree a Product is
            boosted by your boosting query.

          type: string
        tie_breaker:
          $ref: '#/components/schemas/TieBreakDefinition'
        default_value:
          title: Default Value
          description: The default value to use when the scores do not exist for a Product
          type: number
          default: 0
        geo:
          $ref: '#/components/schemas/BaseGeo'
        order:
          title: Order
          enum:
            - desc
            - asc
          default: desc
          type: string
      x-konfig-properties:
        tie_breaker:
          title: Tie Breaker
          default:
            type: relative_difference
            threshold: 0
        geo:
          title: Geo
          description: >-
            The geo point to compute the `_geo_distance` variable against. This
            is only required if
                    `_geo_distance` is present in the formula.
    Page:
      title: Page
      required:
        - url
      type: object
      properties:
        title:
          title: Title
          description: Title of the page
          type: string
          example: My Product Page
        url:
          title: Url
          description: Url of the page
          type: string
          example: https://example.com/miso-tshirt-123ABC
        referrer:
          title: Referrer
          description: Url of the referrer page
          type: string
          example: https://example.com/
    PartialMatchedRecord:
      title: PartialMatchedRecord
      required:
        - product_id
      type: object
      properties:
        product_id:
          title: Product Id
          description: |2-

                    The unique identifier for the product.
                    
          maxLength: 512
          type: string
          example: 123ABC-S-Black
    PollAnswerResponse:
      title: PollAnswerResponse
      required:
        - data
      type: object
      properties:
        message:
          title: Message
          description: >-
            The status of the API response ('success' or other human readable
            api status).
          type: string
          default: success
        data:
          $ref: '#/components/schemas/AnswerData'
      x-konfig-properties:
        data:
          title: Data
          description: >-
            The answer data containing the latest answer, sources, and related
            resources.
    PostQuestionRequest:
      title: PostQuestionRequest
      description: Post questions request
      required:
        - data
      type: object
      properties:
        data:
          title: Data
          type: array
          items:
            $ref: '#/components/schemas/app__schemas__engine_api__request__Question'
    ProductBulkDeleteIn:
      title: ProductBulkDeleteIn
      required:
        - data
      type: object
      properties:
        data:
          $ref: '#/components/schemas/ProductIdList'
    ProductBulkIn:
      title: ProductBulkIn
      required:
        - data
      type: object
      properties:
        data:
          title: Data
          type: array
          items:
            $ref: '#/components/schemas/ProductRecord'
    ProductDetailPageView:
      title: product_detail_page_view
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >-
            Used when a user views the detail page of a product. Viewing a
            product
                    detail page usually indicates a user is interested in the product to certain degree, especially,
                    when the `duration` of the page view is long. When `duration` of the page view is very short (< 5 seconds),
                    `product_detail_page_view` may indicate neural or negative interest in the product. 
          enum:
            - product_detail_page_view
          type: string
        duration:
          title: Duration
          description: >

            How long (in seconds) the user stayed on this page, or consumed
            (listened, read, or watched) a product. This field is

            optional, but it's very important in scenarios where consumption
            duration matters, including

            `product_detail_page_view`, `category_page_view`, `watch`, `listen`,
            and `read`. For example, if a user only

            views or consumes a product for less than 5 seconds, that user is
            probably not interested in the product. On

            the other hand, if a user stays on a page for a while, it usually
            means they are seriously engaging with or

            considering the product. When `duration` is absent, we will use the
            timestamp of the next interaction to

            infer a rough duration value.


            Example:

            ```

            {"duration": 61.5}

            ```
          type: number
          example: 61.5
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    ProductIdList:
      title: ProductIdList
      required:
        - product_ids
      type: object
      properties:
        product_ids:
          title: Product Ids
          type: array
          items:
            type: string
    ProductIds:
      title: ProductIds
      required:
        - ids
      type: object
      properties:
        ids:
          title: Ids
          type: array
          items:
            type: string
    ProductImageView:
      title: product_image_view
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            Used when a user views the image of a product (e.g. to enlarge a
            product photo).
          enum:
            - product_image_view
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    ProductListOut:
      title: ProductListOut
      required:
        - message
        - data
      type: object
      properties:
        message:
          title: Message
          type: string
        data:
          $ref: '#/components/schemas/ProductIds'
    ProductReadOut:
      title: ProductReadOut
      required:
        - message
        - data
      type: object
      properties:
        message:
          title: Message
          type: string
        data:
          $ref: '#/components/schemas/ProductRecord'
    ProductRecord:
      title: ProductRecord
      required:
        - product_id
      type: object
      properties:
        tags:
          title: Tags
          description: |

            The tags that have been associated with the product.

            For example:
            ```
            {"tags": ["TAG_1", "TAG_2", ...]}
            ```
          type: array
          items:
            type: string
          example:
            - cute
            - anime
            - dogs
            - t-shirt
        title:
          title: Title
          description: >

            The title of the product. During a search, Miso will put predictive
            weight behind the title, 

            because it is often the main way users identify a product.
          type: string
          example: Japanese Shiba Inu Dog Eating Miso Soup T-Shirt
        description:
          title: Description
          description: >

            The `description` text of the product. Miso assumes `description`
            contains longer textual content than other 

            string-based fields. For example, term frequency matters more here
            than in a field like the title. Miso’s 

            semantic understanding can extract a lot of valuable information
            from having a product description that is 

            plain-spoken and detailed. 
          type: string
          example: >-
            This cute Shiba inu dog eating Miso soup is perfect for those who
            love Japanese culture.
        product_id:
          title: Product Id
          description: >

            The unique identifier for this product. The Id can be in any format
            you use in your product 

            database (e.g. the product's SKU, UPC, or UUID or serial number). We
            will use this Id to track how users 

            interact with products and content in the Interactions records you
            upload to Miso. It is important to keep the Id 

            consistent between two datasets. For products that have multiple
            variants, you should have a unique 

            `product_id` for each variant, and use `product_group_id` to group
            them together.


            For example, for a T-shirt with SKU `123ABC` that comes in 4 sizes:
            `S`, `M`, `L`, `XL`, we should create four different 

            products:


            ```

            { 
              "product_id": "123ABC-S",
              "product_group_id" "123ABC"
            }

            { 
              "product_id": "123ABC-M",
              "product_group_id" "123ABC"
            }

            { 
              "product_id": "123ABC-L",
              "product_group_id" "123ABC"
            }

            { 
              "product_id": "123ABC-XL",
              "product_group_id" "123ABC"
            }

            ```   

             * Constraints
                * Can't contain `,`
                * Can't start with `_`
                * Length <= 512
          maxLength: 512
          minLength: 1
          type: string
          example: 123ABC-S-Black
        product_group_id:
          title: Product Group Id
          description: >

            The `product_group_id` is used to prevent the same product (but a
            different variant) from showing multiple 

            times in the search or recommendation results. When one product has
            multiple variants (for example, different 

            sizes, colors, or materials), you should assign a unique product_id
            to each variant, but assign the same 

            `product_group_id` to all of them. If `product_group_id` is not
            given, we default to the value of `product_id`. 
          type: string
          example: 123ABC
        parent_id:
          title: Parent Id
          description: >+

            The `parent_id` is used to declare a parent-child relationship
            between two "Products". 

            Such relationships are common in marketplaces and content media
            sites with user generated contents. 

            For example, an E-commerce marketplace (such as E-bay or Amazon) 

            may have "Shops" (as parents) and "Merchandises" 

            (as children), and a social streaming site, such as YouTube, may
            have "Channel" (as parents) and "Video" (as children). In these
            sites, both entities can be modeled as "Products", and can both be
            returned in Search and Recommendation APIs.


            Declaring the parent-child relationships allows Miso to
            automatically propagate interactions from one product to the other.

            For example, when a user "watch" a 

            Video, Miso will propagate this signal to the 

            Channel which publishes this Video, even if users do not directly
            interact with the Channel page. Such implicit 

            interactions

            are particularly useful when making recommendations for Channel
            because it gives Miso much more information 

            about users' interests to different Channels than solely relying on
            users' direct interactions with the 

            them, which happens less often. 


            `parent_id` needs to be a non-empty string referring to the
            `product_id` of the parent product. 

            The parent product can be uploaded in a separate batch, and does not
            need to exist before its children products.


            The implicit interactions will only exist during Miso's training
            process, and will not show up in the 

            Interaction dataset.

          type: string
          example: Nike_Shop_123
        related_ids:
          title: Related Ids
          description: >-
            The product_id or product_group_id of other products that are
            related to this Product
          type: array
          items:
            type: string
        type:
          title: Type
          description: >

            The `type` of product. This is for sites that have more than one
            type of product or content that they want their users 

            to interact with. If your site has only one type of product, you can
            leave this field out. 

            A classic example is travel sites, which have both *hotel* and
            *flight* sales. It is also useful for sites that let 

            users interact with products as well as *product bundles*. For
            example, on YouTube, each video is a product that users 

            can watch, while each channel, containing multiple videos, is also a
            product that users can subscribe to.


            For model quality, it is preferable to model all these distinct
            product types in the same data set, so that a user's 

            interests for one type of product can inform their interests in
            another type of products. The `type` field helps Miso 

            make these distinctions.
          type: string
          example: clothes
        language:
          title: Language
          description: >

            The `language` of the product description and content in [two-letter
            ISO 639-1 code](https://en.wikipedia.org/wiki/ISO_639-1). For
            example, English = `en`, Chinese = `zh`. 

            Miso will use this field to determine the proper way to index the
            product description. If this field is not specified, 

            we will determine the language automatically. 


            We also use the language field to determine users’ interests in
            content of different languages. This is particularly 

            important for content media sites that have different languages of
            content. 


            * Constraints:
                * [Two-letter ISO 639-1 code](https://en.wikipedia.org/wiki/ISO_639-1). 
                For example, English = `en`, Chinese = `zh`.
          minLength: 2
          type: string
          example: en
        created_at:
          title: Created At
          description: >

            The time when the product was first created or became available on
            your site as an ISO-8601 date or datetime string.  
          anyOf:
            - type: string
              format: date-time
            - type: string
              format: date
        published_at:
          title: Published At
          description: >

            The time when the product was published as an ISO-8601 date or
            datetime string. 
          anyOf:
            - type: string
              format: date-time
            - type: string
              format: date
        updated_at:
          title: Updated At
          description: >

            The time when the product was updated as an ISO-8601 date or
            datetime string. 
          anyOf:
            - type: string
              format: date-time
            - type: string
              format: date
        categories:
          title: Categories
          description: >

            In Miso, you describe a product or content category as a
            hierarchical list of strings from broad to narrow, 

            called a `category`. (See the `category_page_view` interaction.) 


            Use the `categories` field of products to specify the hierarchical
            category or categories that the product 

            belongs to. A product may belong to only a single `category`, or
            multiple. 


            For example, a product could be in both:
             * *Toys & Games > Toys > Dolls, Playsets & Toy Figures > Stuffed Animals*, and
             * *Arts & Entertainment > Hobbies & Creative Arts > Collectibles*. 

             This field should be a list of a list of strings, where category levels go from broad to narrow, such as: 

            ```

            {"categories":
                [
                    // the first category the product belongs to
                    ["TOYS & GAMES", "TOYS", "DOLLS, PLAYSETS & TOY FIGURES", "STUFFED ANIMALS"],
                    // the second category the product belongs to
                    ["ARTS & ENTERTAINMENT", "HOBBIES & CREATIVE ARTS", "COLLECTIBLES"]
                ]
            }

            ```


            If your product taxonomy has only one single level, that is not an
            issue:

            ```

            {"categories":
                [
                    // the first category the product belongs to
                    ["Toys"],
                    // the second category the product belongs to
                    ["Collectibles"]
                ]
            }

            ```


            The categories are optional, but very important for profiling the
            products and tracking users' preferences. 

            (See also the `category_page_view` interaction)
          type: array
          items:
            type: array
            items:
              type: string
          example:
            - - Clothing, Shoes & Jewelry
              - Women
              - T-Shirts
            - - Novelty
              - Tops & Tees
              - T-Shirts
        url:
          title: Url
          description: >

            Url to the product detail page. This is for displaying the product
            in your Dojo Sandboxes and is not used for Engine training. 

            It is optional, but strongly recommended for a better Sandbox
            experience.
          maxLength: 65536
          minLength: 1
          type: string
          format: uri
          example: https://example.com/miso-tshirt-123ABC
        cover_image:
          title: Cover Image
          description: >

            The URL of the cover image  of the product. This is for displaying
            the product in your Dojo Sandboxes and 

            is not used for Engine training. It is optional, but strongly
            recommended for a better Sandbox experience. 
          maxLength: 65536
          minLength: 1
          type: string
          format: uri
          example: https://example.com/miso-tshirt-123ABC.jpg
        original_price:
          title: Original Price
          description: >

            The (original) price of the product. We only use this number to
            calculate the amount of discount, and use that

            to profile user behaviors.


            * Constraints:
                * Need to be a number, but no constraint on the range of the number
          type: number
          example: 20
        sale_price:
          title: Sale Price
          description: |

            The sale price of the product. 

            * Constraints:
                * Need to be a number, but no constraint on the range of the number
          type: number
          example: 15
        margin:
          title: Margin
          description: >

            The margin of the product. Note that for our margin optimization
            algorithm to work, the margin you specify here
             does not need to be the actual dollar amount, but it needs to be something in proportion to that. 

            * Constraints:
                * Need to be a number, but no constraint on the range of the number
          type: number
          example: 15
        size:
          title: Size
          description: >

            The size of the product. For example, for an eCommerce site that
            sells T-shirts, each T-shirt might come in

            several different sizes. In this case, we recommend that you should
            create one product entry for 

            each size variant. When Miso generate search or recommendation
            results, we use the `product_group_id` to remove 

            different variants of the same product, and only show the variant
            that the user is most likely to buy. 
          type: string
          example: S
        color:
          title: Color
          description: >

            The color of the products. Similarly to `size`, when `color` of the
            products matters, it is recommended to create 

            one product for each color variant of a product. When Miso generate
            search or recommendation results, 

            we use the `product_group_id` to remove variants of the same
            product, and only show the 

            variant that the user is most likely to buy. 
          type: string
          example: Black
        material:
          title: Material
          description: >

            The material of the products. Similarly to `size` and `color`, if
            `material` of the product matters and there 

            are multiple material variants, we should create one product for
            each material variant. When Miso generates search or 

            recommendation results, we use the `product_group_id` to remove
            variants of the same product, and only show the 

            variant that the user is most likely to buy. 
          type: string
          example: Cotton
        condition:
          title: Condition
          description: >

            The condition of the product. By default, we assume `condition`=
            `NEW`
          enum:
            - NEW
            - USED
            - REFURBISHED
          type: string
          default: NEW
        brand:
          title: Brand
          description: |

            The brand of the product.
          type: string
          example: Miso Corp.
        authors:
          title: Authors
          description: >

            The author(s) of the product or content asset. This field needs to
            be an array of strings.
          type: array
          items:
            type: string
          example:
            - Andy Hsieh
        publishers:
          title: Publishers
          description: >

            The publisher(s) of the product or content asset. This field needs
            to be an array of strings.
          type: array
          items:
            type: string
          example:
            - O'Reilly Media
        collections:
          title: Collections
          description: |

            The collection(s) the product belongs to.
          type: array
          items:
            type: string
          example:
            - Anime T-Shirt Collection
            - Superhero T-Shirt Collection
        availability:
          title: Availability
          description: >

            The availability of the product. Miso mainly uses `availability` to
            filter `OUT_OF_STOCK` items out of its recommendations.

            As a default, we assume the product is `IN_STOCK`.
          enum:
            - IN_STOCK
            - OUT_OF_STOCK
            - PRE_ORDER
          type: string
        location:
          title: Location
          description: >

            The location information of the product (e.g. for hotels or
            restaurants). We support geolocation filtering 

            and sorting when creating search and recommendation results if
            location information is given. 
          anyOf:
            - type: array
              items:
                $ref: '#/components/schemas/LocationInformation'
            - $ref: '#/components/schemas/LocationInformation'
        rating:
          title: Rating
          description: >

            The overall rating of the product in the range of [0, 5]. If you use
            a different rating scale, please convert it

            to the range of [0, 5].
          type: number
          example: 5
        html:
          title: Html
          description: >

            The HTML content of the product. Miso will search against this field
            and apply semantic understanding in a way that is

            similar to the `description` field, but with HTML tags removed. 
          type: string
        subtitle:
          title: Subtitle
          description: |

            The subtitle of the product (usually for contents).
          type: string
        headers:
          title: Headers
          description: >

            The headers in the content. This usually corresponds to `<h1>`,
            `<h2>`, `<h3>` ... tags in HTML. This field need to be an array of
            strings 
          type: array
          items:
            type: string
        paragraphs:
          title: Paragraphs
          description: >

            The text paragraphs in the content. This usually corresponds to
            `<p>` tags in HTML. This field need to be an array of strings 
          type: array
          items:
            type: string
        anchors:
          title: Anchors
          description: >

            The anchor texts paragraphs in the content. This usually corresponds
            to `<a>` tags in HTML. This field need to be an array of strings 
          type: array
          items:
            type: string
        children:
          title: Children
          description: >

            Children objects of the product, such as chapters of a book, or
            sections of a podcast.

            Children are only useful for long-form contents, and are only used
            for snippet extraction purpose.
          type: array
          items:
            $ref: '#/components/schemas/ChildrenObject'
        enable_question_answering:
          title: Enable Question Answering
          description: >

            Whether to enable question answering capability against the `html`
            field.
          type: boolean
          default: false
        custom_attributes:
          title: Custom Attributes
          description: >

            Dictionary of custom attributes for the product. You can specify
            attributes specific to your business 

            in a `{"KEY":VALUE}` format, where `KEY` must be a string, and
            `VALUE` can be:

            * a `bool`

            * a `string` or an `array of string`

            * a `number` or an `array of numbers`

            * an `array of objects`

            * `null` 




            For example, a video streaming site using Miso may have the movie
            *Jumanji* with the following custom attributes: 


            ```

            {
              "custom_attributes": {
                "cast": [
                  "Robin Williams", "Jonathan Hyde", ...
                ],
                "director": "Joe Johnston",
                "genres": [
                  "Adventure", "Fantasy", "Family"
                ],
                "filming_locations": [
                   {"country": "USA", "state": "New Hampshire", "city": "Keene"},
                   {"country": "Canada", "state": "British Columbia", "city": "Vancouver"}
                ],
                "popularity": 7.439,
                "adult": false
              }
            }

            ```


            **The custom attribute types need to be consistent across every
            record in the dataset**. 

            For instance, in the example above, the **cast** attribute needs to
            be a `string` or `an array of string` or `null` 

            for every record in the dataset that specify **cast** attribute.



            Similarly, the popularity attribute needs to be a `number`, `an
            array of numbers`, or `null` for every record in the 

            dataset that specifies the popularity attribute. If you try to
            insert a record with an incompatible data type, the 

            insertion for that record will fail. 
          type: object
          additionalProperties:
            anyOf:
              - type: boolean
              - type: integer
              - type: number
              - type: string
              - type: array
                items:
                  type: number
              - type: array
                items:
                  type: string
              - type: object
                additionalProperties:
                  anyOf:
                    - type: string
                    - type: number
                    - type: integer
                    - type: boolean
              - type: array
                items:
                  type: object
                  additionalProperties:
                    anyOf:
                      - type: string
                      - type: number
                      - type: integer
                      - type: boolean
                      - type: array
                        items:
                          type: string
                      - type: array
                        items:
                          type: number
          example:
            cast:
              - Robin Williams
              - Jonathan Hyde
            director: Joe Johnston
            genres:
              - Adventure
              - Fantasy
              - Family
            popularity: 7.439
            adult: false
    ProductToProductsResponse:
      title: ProductToProductsResponse
      required:
        - data
      type: object
      properties:
        message:
          title: Message
          type: string
          default: success
        data:
          $ref: '#/components/schemas/ProductToProductsResponseBody'
    ProductToProductsResponseBody:
      title: ProductToProductsResponseBody
      required:
        - products
      type: object
      properties:
        took:
          title: Took
          description: Number of milliseconds Miso took to retrieve the results.
          type: integer
          default: 0
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          default: 00000000-0000-0000-0000-000000000000
          example: 123e4567-e89b-12d3-a456-426614174000
        products:
          title: Products
          description: Product recommendation results.
          type: array
          items:
            $ref: '#/components/schemas/Record'
    PromoPageView:
      title: promo_page_view
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            Used when a user views a specific promotional or curated marketing
            page about certain products or content.
          enum:
            - promo_page_view
          type: string
        duration:
          title: Duration
          description: >

            How long (in seconds) the user stayed on this page, or consumed
            (listened, read, or watched) a product. This field is

            optional, but it's very important in scenarios where consumption
            duration matters, including

            `product_detail_page_view`, `category_page_view`, `watch`, `listen`,
            and `read`. For example, if a user only

            views or consumes a product for less than 5 seconds, that user is
            probably not interested in the product. On

            the other hand, if a user stays on a page for a while, it usually
            means they are seriously engaging with or

            considering the product. When `duration` is absent, we will use the
            timestamp of the next interaction to

            infer a rough duration value.


            Example:

            ```

            {"duration": 61.5}

            ```
          type: number
          example: 61.5
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    QAAutocompleteResponse:
      title: QAAutocompleteResponse
      description: Autocomplete Response
      required:
        - data
      type: object
      properties:
        message:
          title: Message
          type: string
          default: success
        data:
          $ref: '#/components/schemas/QAAutocompleteResponseBody'
    QAAutocompleteResponseBody:
      title: QAAutocompleteResponseBody
      description: Autocomplete Response
      required:
        - completions
      type: object
      properties:
        took:
          title: Took
          description: Number of milliseconds Miso took to retrieve the results.
          type: integer
          default: 0
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          default: 00000000-0000-0000-0000-000000000000
          example: 123e4567-e89b-12d3-a456-426614174000
        completions:
          title: Completions
          type: array
          items:
            $ref: '#/components/schemas/app__schemas__engine_api__response__Question'
    QAResponse:
      title: QAResponse
      required:
        - data
      type: object
      properties:
        message:
          title: Message
          type: string
          default: success
        data:
          $ref: '#/components/schemas/QAResponseBody'
    QAResponseBody:
      title: QAResponseBody
      required:
        - total
        - spellcheck
        - answers
      type: object
      properties:
        took:
          title: Took
          description: Number of milliseconds Miso took to retrieve the results.
          type: integer
          default: 0
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          default: 00000000-0000-0000-0000-000000000000
          example: 123e4567-e89b-12d3-a456-426614174000
        total:
          title: Total
          description: Total number of Question-Answer hits.
          type: integer
          example: 1000
        spellcheck:
          $ref: '#/components/schemas/SpellCheckResponse'
        answers:
          title: Answers
          description: The Question-Answer results.
          type: array
          items:
            $ref: '#/components/schemas/RecordWithAnswer'
      x-konfig-properties:
        spellcheck:
          title: Spellcheck
          description: >-
            Spellcheck results. You can use the information in this object to
            prompt users with the correct spelling.
    QueryFilter:
      title: QueryFilter
      required:
        - query
      type: object
      properties:
        query:
          title: Query
          description: Query in Lucene syntax
          type: string
        key:
          title: Key
          description: User friendly label of the query result
          type: string
    QueryFilterRequireKey:
      title: QueryFilterRequireKey
      required:
        - query
        - key
      type: object
      properties:
        query:
          title: Query
          description: Query in Lucene syntax
          type: string
        key:
          title: Key
          description: User friendly label of the query result
          type: string
    QuestionAnsweringRequest:
      title: QuestionAnsweringRequest
      required:
        - q
        - min_probability
      type: object
      properties:
        version:
          title: Version
          description: >

            The model version to use.

            * **v1.2**: First stable version

            * **v1.3**: Improve keyword extraction that make answers more
            precise
          enum:
            - v1.2
            - v1.3
          default: v1.2
          example: v1.2
          type: string
        q:
          title: Q
          description: The question user has entered.
          minLength: 1
          type: string
          example: what is gradient descent
        min_probability:
          title: Min Probability
          description: >

            Minimum acceptable probability (between 0.0 and 1.0). The answers
            whose probability is lower than this number will be excluded

            from the response.
          maximum: 1
          minimum: 0
          type: number
          example: 0.7
        rows:
          title: Rows
          description: Number of search results to return.
          type: integer
          default: 1
        fl:
          title: Fl
          description: >

            List of fields to retrieve. Each Q&A response, by default, return
            two fields `answer` and `product_id`, where

            `answer` is an object with the information about the answer
            paragraph while

            `product_id` identifies the *Product* from which the answer is
            extracted.


            For example, the following is a sample response from the API:

            ```

            {
             "product_id": "ABC-123",
             "answer":
              {
               "html": "<p>Python is an interpreted programming language</p>",
               "text": "Python is an interpreted programming language",
               "css_selector": ":root > div:nth-child(1) > p:nth-child(2)",
               "probability": 0.99
              }
            }

            ```


            You can use `fl` parameter to retrieve additional product fields.
            For example, the following request

            additionally retrieves the `title` field for each product along

            with the `product_id` and `answer`, which are always returned.


            ```

            {"fl": ["title"]}

            ```


            You can also match field names by using `*` as a wildcard. For
            example, the query below retrieves the `title`

            and all the `custom_attributes` fields.


            ```

            {"fl": ["title", "custom_attributes.*"]}

            ```


            The following request retrieves all the available product fields:


            ```

            {"fl": ["*"]}

            ```


            For the lowest latency, use an empty array (which is the default) to
            retrieve just the `product_id` and `answer` fields.

            ```

            {"fl": []}

            ```
          type: array
          items:
            type: string
          default: []
        spellcheck:
          $ref: '#/components/schemas/SpellCheckRequest'
        enable_answer_html:
          title: Enable Answer Html
          description: >-
            Whether to return HTML of the answer paragraph. If you don't need
            the HTML content of the
                    answer paragraph, setting this parameter to `false` will reduce the response size and lower the
                     response latency.
          type: boolean
          default: false
        enable_answer_block:
          title: Enable Answer Block
          description: >

            Whether to return *answer block*.

            In addition to answer paragraph, Miso can additionally return
            *answer block*.

            Answer block is an ancestor HTML node of the answer paragraph that
            contains the relevant context.

            The answer block is particularly useful for applications that not
            only want to show

            the answer itself but also the **context** surrounding the answer.


            Answer block is the smallest HTML element that contains the relevant
            context. However, not all the content

            inside this node is relevant. You can use the returned
            `relevant_children_slice` field

            to identify a portion of this node that is relevant to the answer.
          type: boolean
          default: false
        fq:
          title: Fq
          description: >


            Defines a query in Solr syntax that can be used to restrict the
            superset of

            products to return, without influencing the overall ranking. `fq`
            can enable users to drill down to products

            with specific features based on different product attributes


            For example, the query below limits the search results to only show
            products whose size is either `M` or `S` and

            brand is `Nike`:


            ```

            {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

            ```


            You can use `fq` to apply filters against your custom attributes as
            well. For example, the query below limits the

            search results to only products whose `designer` attribute is
            `Calvin Klein`


            ```

            {"fq": "attributes.designer:\"Calvin Klein\""}

            ```


            `fq` can also limit search results by numerical range. For example,
            the following query limits the results to

            products that have `rating >= 4`.


            ```

            {"fq": "rating:[4 TO *]"}

            ```
          type: string
        boost_fq:
          title: Boost Fq
          description: >

            Defines a query in Solr syntax that can be used to boost a subset of
            products to the top of the ranking, or to

            specific *boost positions* (See `boost_positions` parameter below.)

            For example, the query below will promote all the relevant products
            whose brand is `Nike` to the top of

            recommendation list:


            ```

            {
                "boost_fq": "brand:\"Nike\""
            }

            ```


            For a slightly more complex example, the query below will promote
            the Nike products which have also been tagged

            as `ON SALE` to the top of the ranking:

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
            }

            ```

            It is worth mentioning that, Miso will only boost products that are
            relevant and have high likelihood to convert,

            and will not boost a low performance product only because it matches
            the boosting query.


            Depending on your boosting rules, in certain cases, you would like
            to prevent recommendation results from being

            too monotone due to boosting. With Miso, you have two tools to do
            so.


            First, you can specify `boost_positions` to place promoted products
            at specific positions in the ranking. For

            example, the query below will place boosted products only at the
            first and fourth places in the ranking

            (positions are 0-based), and place the remaining products in their
            original ranking, skipping these two positions.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "boost_positions": [0, 3]
            }

            ```


            The second tool is `diversification`. `diversification` parameter,
            on a best-effort basis, will try to

            maintain a minimum distance between products that have the same
            attributes. For example, the following query

            will place products made by the same brand apart from each other.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "diversification": {
                   "brand": {"minimum_distance": 1}
                }
            }

            ```
          type: string
        boost_positions:
          title: Boost Positions
          description: >

            Defines a list of 0-based positions you want to place the boosted
            products at.


            For example, the query below will promote products whose brand is
            `Nike` as the top and second recommendations:

            ```

            {
                "boost_fq": "brand:\"Nike\"",
                "boost_positions": [0, 1]
            }

            ```

            If `boost_positions` is not specified (which is the default
            behavior), all the boosted products will be ranked

            higher than the rest of the products.
          type: array
          items:
            type: integer
        boost_rules:
          title: Boost Rules
          description: >

            Define a list of boosting rules that will be applied to the search
            or recommendation results simultaneously. `boost_rules`

            parameter is particularly useful when you want to boost more than
            one sets of products, and promote each of them to different

            positions. For example, the query below will promote products whose
            brand is `Nike` to the top

            and second results, and products whose brand is `Adidas` to the
            third and fourth results:

            ```

            {
                "boost_rules": [
                    {
                        "boost_fq": "brand:\"Nike\"",
                        "boost_positions": [0, 1]
                    },
                    {
                        "boost_fq": "brand:\"Adidas\"",
                        "boost_positions": [2, 3]
                    }
                ]
            }

            ```
          type: array
          items:
            $ref: '#/components/schemas/BoostingFilterBase'
          default: []
        geo:
          $ref: '#/components/schemas/GeoQuery'
        boost_probability_threshold:
          title: Boost Probability Threshold
          description: >

            Minimum probability required for an answer to be boosted. If not
            specified, the `min_probability` will be used.
          type: number
      x-konfig-properties:
        spellcheck:
          title: Spellcheck
          description: Spellcheck configuration
          default:
            enable_auto_spelling_correction: true
        geo:
          title: Geo
          description: >

            When set, filter result to include only products within certain
            geographic range from given point will be returned,

            or to boost product within the same range.


            Product should have a field that holds the location of the product,
            `location` is used by default,

            but other field can also be used.


            Distance can be in miles or kilometers. If `distance_unit` is not
            set, `mile` will be used.


            For example, to limit results to products within 100 miles of New
            York city:

            ```

            {
                "geo": {
                    "filter": [{
                        "lat": 40.73061,
                        "lon": -73.93524,
                        "distance": 100
                    }]
                }
            }

            ```


            To boost products within 2 kilometers around Alcatraz Island
            according to `loc` field:

            ```

            {
                "geo": {
                    "boost": [{
                        "field": "loc",
                        "lat": 37.82667,
                        "lon": -122.42278,
                        "distance": 2,
                        "distance_unit": "km"
                    }]
                }
            }

            ```
    QuestionAutocompleteRequest:
      title: QuestionAutocompleteRequest
      description: Post question autocomplete request
      required:
        - q
      type: object
      properties:
        q:
          title: Q
          description: The query user has entered so far
          minLength: 1
          type: string
          example: what is g
        rows:
          title: Rows
          description: Number of autocomplete results to return.
          type: integer
          default: 5
    QuestionRequest:
      title: QuestionRequest
      required:
        - question
      type: object
      properties:
        user_id:
          title: User Id
          description: >-
            The user who made the query. For an anonymous visitor, use
            `anonymous_id` instead.
          type: string
        anonymous_id:
          title: Anonymous Id
          description: The anonymous visitor who made this query.
          type: string
        fq:
          title: Fq
          description: >


            Defines a query in Solr syntax that can be used to restrict the
            superset of

            products to return, without influencing the overall ranking. `fq`
            can enable users to drill down to products

            with specific features based on different product attributes


            For example, the query below limits the search results to only show
            products whose size is either `M` or `S` and

            brand is `Nike`:


            ```

            {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

            ```


            You can use `fq` to apply filters against your custom attributes as
            well. For example, the query below limits the

            search results to only products whose `designer` attribute is
            `Calvin Klein`


            ```

            {"fq": "attributes.designer:\"Calvin Klein\""}

            ```


            `fq` can also limit search results by numerical range. For example,
            the following query limits the results to

            products that have `rating >= 4`.


            ```

            {"fq": "rating:[4 TO *]"}

            ```
          type: string
        question:
          title: Question
          description: The question for which an answer is requested.
          type: string
        parent_question_id:
          title: Parent Question Id
          description: >-
            The UUID of the parent question if the current question is a
            follow-up to a previous question.
          type: string
          format: uuid
        yearly_decay:
          title: Yearly Decay
          description: The yearly decay rate for the answer score.
          type: number
          default: 0.93
        source_fl:
          title: Source Fl
          description: >+

            A list of fields to be returned for the `sources`. Any fields in
            uploaded product can be assigned, including fields in
            `custom_attributes`.


            If specificed field does not exist, that field will not be included
            in the result.

            If you use different schema for `custom_attributes` across different
            products, it is possible that not all returned sources has the some
            fields.


            For example, if you include `published_at` and `custom_attributes`
            in `source_fl`:


            ```json

            {
                "question":"Explain Python GIL",
                "source_fl":["published_at", "custom_attributes.rating"]
            }

            ```


            The answer will contain `published_at` field for each source:


            ```json

            {
                "message": "success",
                "data": {
                    "question": "Explain Python GIL",
                    "question_id": "57aeb083-b943-43b1-86ab-b6108788dd50",
                    "parent_question_id": null,
                    "answer_stage": "Generating summary",
                    "finished": true,
                    "answer": "# Explain Python GIL\n\n## Why do we need the GIL? [1]\n\nThe GIL is currently an essential part of the CPython...[omitted for simplicity]",
                    "sources": [
                        {
                            "published_at": "2022-05-20T00:00:00+00:00",
                            "custom_attributes": {
                                "rating": 4.7
                            },
                            "product_id": "9781800207721",
                            "title": "Multiprocessing – When a Single CPU Core Is Not Enough",
                            "child_title": "Multiprocessing – When a Single CPU Core Is Not Enough",
                            "child_id": "16",
                            "snippet": "Remember the segmentation faults we saw in Chapter 11, ...[omitted]"
                        },
                        {
                            "published_at": "2015-02-26T00:00:00+00:00",
                            "custom_attributes": {
                                "rating": 4.3
                            },
                            "product_id": "9780134034416",
                            "title": "5. Concurrency and Parallelism",
                            "child_title": "5. Concurrency and Parallelism",
                            "child_id": "12",
                            "snippet": "<mark>Click here to view code image\n...[omitted]</mark>"
                        },
                        {
                            "published_at": "2020-04-30T00:00:00+00:00",
                            "custom_attributes": {
                                "rating": 3.5
                            },
                            "product_id": "9781492055013",
                            "title": "1. Understanding Performant Python",
                            "child_title": "1. Understanding Performant Python",
                            "child_id": "2",
                            "snippet": "<mark>Although it still locks Python into running ...[omitted]</mark>"
                        },
                        {
                            "published_at": "2019-11-15T00:00:00+00:00",
                            "custom_attributes": {
                                "rating": 4.2
                            },
                            "product_id": "9780134854717",
                            "title": "7. Concurrency and Parallelism",
                            "child_title": "7. Concurrency and Parallelism",
                            "child_id": "16",
                            "snippet": "<mark>Although Python supports multiple threads of execution...[omitted]</mark>"
                        }
                    ],
                    "related_resources": []
                }
            }

            ```

          type: array
          items:
            type: string
          default:
            - title
        related_resource_fl:
          title: Related Resource Fl
          description: >-
            A list of fields to be returned for the `related_resources`.
            Example: `['title', 'url']`.
          type: array
          items:
            type: string
          default:
            - title
        cite_start:
          title: Cite Start
          description: 'The citation start marker. Example: `[` or `{`'
          type: string
        cite_end:
          title: Cite End
          description: 'The citation end marker. Example: `]` or `}`'
          type: string
    QuestionResponse:
      title: QuestionResponse
      required:
        - data
      type: object
      properties:
        data:
          $ref: '#/components/schemas/QuestionResponseData'
        message:
          title: Message
          description: Human-readable message.
          type: string
          default: success
      x-konfig-properties:
        data:
          title: Data
          description: Question response data.
    QuestionResponseData:
      title: QuestionResponseData
      required:
        - question_id
      type: object
      properties:
        question_id:
          title: Question Id
          description: The UUID for the submitted question.
          type: string
          format: uuid
    Range:
      title: Range
      type: object
      properties:
        to:
          title: To
          description: End of the range (exclusive).
          anyOf:
            - type: string
            - type: number
        from:
          title: From
          description: Start of the range (inclusive).
          anyOf:
            - type: string
            - type: number
        key:
          title: Key
          description: User friendly label of the range
          type: string
    RangeRequireKey:
      title: RangeRequireKey
      required:
        - key
      type: object
      properties:
        to:
          title: To
          description: End of the range (exclusive).
          anyOf:
            - type: string
            - type: number
        from:
          title: From
          description: Start of the range (inclusive).
          anyOf:
            - type: string
            - type: number
        key:
          title: Key
          description: User friendly label of the range
          type: string
    Rate:
      title: rate
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: |

            Used when a user gives a rating to a product or piece of content.
          enum:
            - rate
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
        rating:
          title: Rating
          description: >

            The rating the user gave in the range of [0, 5]. This field is only
            required by the `rate` interaction. As a

            convention in the RecSys community, a rating >= 3.5 is considered
            positive, a rating <= 2 is negative,

            and otherwise a rating is neutral. If you use any other rating
            scale, please normalize it to a [0, 5] scale.
          type: number
          example: 5
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    Read:
      title: read
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            Used to record when and for how long a user reads a piece of written
            content.
          enum:
            - read
          type: string
        duration:
          title: Duration
          description: >

            How long (in seconds) the user stayed on this page, or consumed
            (listened, read, or watched) a product. This field is

            optional, but it's very important in scenarios where consumption
            duration matters, including

            `product_detail_page_view`, `category_page_view`, `watch`, `listen`,
            and `read`. For example, if a user only

            views or consumes a product for less than 5 seconds, that user is
            probably not interested in the product. On

            the other hand, if a user stays on a page for a while, it usually
            means they are seriously engaging with or

            considering the product. When `duration` is absent, we will use the
            timestamp of the next interaction to

            infer a rough duration value.


            Example:

            ```

            {"duration": 61.5}

            ```
          type: number
          example: 61.5
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    RecResponse:
      title: RecResponse
      required:
        - data
      type: object
      properties:
        message:
          title: Message
          type: string
          default: success
        data:
          $ref: '#/components/schemas/BaseResponseBody'
    Record:
      title: Record
      required:
        - product_id
      type: object
      properties:
        product_id:
          title: Product Id
          description: |2-

                    The unique identifier for the product.
                    
          maxLength: 512
          type: string
          example: 123ABC-S-Black
    RecordWithAnswer:
      title: RecordWithAnswer
      required:
        - product_id
        - answer
      type: object
      properties:
        product_id:
          title: Product Id
          description: >-
            The unique identifier of the product whose content contains the
            answer.
          maxLength: 512
          type: string
        answer:
          $ref: '#/components/schemas/Answer'
        answer_block:
          $ref: '#/components/schemas/AnswerBlock'
      x-konfig-properties:
        answer:
          title: Answer
          description: >-
            The answer paragraph (i.e. a `<p>` node) whose text content can
            answer users' question.
        answer_block:
          title: Answer Block
          description: |2-

                    In addition to the answer paragraph, we also return the **answer block**.
                    Answer block is the ancestor node of the answer paragraph that cover not only the answer, but also the relevant
                    context. This is particularly useful for applications that want to show
                    the answer itself but also the relevant context surrounding the answer.

                    Answer block is the smallest HTML element that contains the relevant context. However, not all the content
                    inside this node is relevant. You can use the `relevant_children_slice` to identify a portion inside this
                    block that is relevant to the answer.
                    
    RecordWithFound:
      title: RecordWithFound
      description: >-
        Product record but support `_found=true / false` field. When
        _found=false,

        the product_id will not be available.
      required:
        - product_id
      type: object
      properties:
        product_id:
          title: Product Id
          description: |2-

                    The unique identifier for the product.
                    
          maxLength: 512
          type: string
          example: 123ABC-S-Black
    Refund:
      title: refund
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: |

            Used when a user requests a refund of products they bought.
          enum:
            - refund
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    RemoveFromCart:
      title: remove_from_cart
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: |

            Used when a user removes a product from their shopping cart.
          enum:
            - remove_from_cart
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    RemoveFromCollection:
      title: remove_from_collection
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: |

            Used when a user removes a product from their personal collection.
          enum:
            - remove_from_collection
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    Search:
      title: search
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            Used to record a search event with the keywords and filters the user
            used. What a user searches for

            is a very powerful signal about their interests and what they will
            eventually buy or consume, so it is important

            to capture this information with high fidelity.
          enum:
            - search
          type: string
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
        search:
          $ref: '#/components/schemas/SearchInformation'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
        search:
          title: Search
          description: >

            The search keywords and filters the user uses. This is only required
            by `search` interaction.
    SearchInformation:
      title: SearchInformation
      type: object
      properties:
        keywords:
          title: Keywords
          description: >

            The search keywords user use. Search keywords are strong signals to
            users' interests.
          type: string
          default: ''
        filters:
          title: Filters
          description: >

            Dictionary of filters users apply to the search results in the
            following format:
             `{"FIELD": ["SELECTION_1", "SELECTION_2"]}`.
          type: object
          additionalProperties:
            type: array
            items:
              type: string
    SearchRequest:
      title: SearchRequest
      type: object
      properties:
        engine_id:
          title: Engine Id
          description: >

            The engine you want to get results from. When you have more than one
            engine, you can use this parameter to

            specify the specific engine you want to get results from. If not
            specified, the default engine will be used.
          type: string
        user_id:
          title: User Id
          description: >

            The user who made the query and for whom Miso will personalize the
            results. For an anonymous visitor, use `anonymous_id` instead.
          type: string
        anonymous_id:
          title: Anonymous Id
          description: >-
            The anonymous visitor who made the query and for whom Miso will
            personalize the results. Either
                    `user_id` or `anonymous_id` needs to be specified for personalization to work. 
          type: string
        user_hash:
          title: User Hash
          description: >

            The hash of `user_id` (or `anonymous_id`) encrypted by your [Secret
            API Key](https://api.askmiso.com).

            `user_hash` is required to prevent unauthorized API access if you
            are

            making API calls with a [Publishable API
            Key](https://api.askmiso.com).


            You should generate the user_hash via HMAC scheme: you encrypt the
            desired user_id (or anonymous_id) with your

            [Secret API Key](https://api.askmiso.com) on your backend server,

            and then let the front-end code send the generated user_hash to Miso
            APIs to

            verify the identity of the API caller.


            As long as the [Secret API Key](https://api.askmiso.com)
             is kept secret, the user_hash prevents a malicious attacker from making unauthorized
            API calls or impersonating any of your users.


            Miso APIs accept the case-incentive "hex digest" of user hash, a
            sample Python 3 code to generate it on your backend server

            is as follow:


            ```python

            import hashlib

            import hmac


            YOUR_MISO_SECRET_API_KEY = "039c501ac8dfcac91"

            key_bytes = YOUR_MISO_SECRET_API_KEY.encode()

            user_id = "USER_123" # or anonymous_id

            user_id_bytes = user_id.encode()

            user_hash = hmac.new(
                key_bytes,
                user_id_bytes,
                hashlib.sha256).hexdigest()
            # user_hash is "7eb04da5e..."

            ```


            You can find more examples for other languages in this [Github
            Gist](https://gist.github.com/thewheat/7342c76ade46e7322c3e)
          type: string
        user_cohort:
          title: User Cohort
          description: >

            The user cohort you want to cold-start the recommendation with. For
            example, the following query will make

            recommendations based on the preferences of the users whose
            `country="United States"`, and `gender="Female"`

            in the User Profile dataset.

            ```

            {
                "user_cohort": {
                    "country": "United States",
                    "gender": "Female"
                }
            }

            ```
          type: object
          additionalProperties:
            anyOf:
              - type: boolean
              - type: string
        rows:
          title: Rows
          description: Number of search results to return.
          type: integer
          default: 5
        type:
          title: Type
          description: >

            The type of products to return. Use this parameter to make the API
            return only

            a certain type of products (see [Product
            APIs](https://api.askmiso.com)).


            This is particularly useful for sites that have multiple types of
            products:

            For example, on a marketplace site, YOu may model *merchandise* and
            *store* as two types of *products*. You can

            then use type parameter to limit the recommendation or search
            results to return only one kind of them.


            For instance, the following query will return only *store* products:
             ```
            {"type": "store"}
             ```

            For another example, on a travel website, you might have: *hotel*,
            *thing to do*, and *restaurant*,

            three kinds

            of products. You can use `type` parameter to limit results to one
            kind of them. For instance, the following

            query will limit the results to only *hotels* product:
             ```
            {"type": "hotel"}
             ```
          type: string
        dedupe_product_group_id:
          title: Dedupe Product Group Id
          description: >

            Whether to dedupe product based on `product_group_id`. If
            `dedupe_product_group_id=true`,

            Miso will prevent products with the same `product_group_id` from
            showing multiple

            times in the search or recommendation results.



            This is particular useful when one product has multiple variants
            (for example, different

            sizes, colors, or materials), and you only want to show this product
            only once in the search or recommendation

            results. Miso will then return the variant that is most likely to be
            of the user's interest.
          type: boolean
          default: true
        additional_interactions:
          title: Additional Interactions
          description: >

            A list of additional interaction records. You can use this fields to
            simulate user interactions without

            actually writing them to the interaction dataset.
          type: array
          items:
            anyOf:
              - $ref: '#/components/schemas/ProductDetailPageView'
              - $ref: '#/components/schemas/Search'
              - $ref: '#/components/schemas/AddToCart'
              - $ref: '#/components/schemas/RemoveFromCart'
              - $ref: '#/components/schemas/Checkout'
              - $ref: '#/components/schemas/Refund'
              - $ref: '#/components/schemas/Subscribe'
              - $ref: '#/components/schemas/AddToCollection'
              - $ref: '#/components/schemas/RemoveFromCollection'
              - $ref: '#/components/schemas/Read'
              - $ref: '#/components/schemas/Watch'
              - $ref: '#/components/schemas/Listen'
              - $ref: '#/components/schemas/Like'
              - $ref: '#/components/schemas/Dislike'
              - $ref: '#/components/schemas/Share'
              - $ref: '#/components/schemas/Rate'
              - $ref: '#/components/schemas/Bookmark'
              - $ref: '#/components/schemas/Complete'
              - $ref: '#/components/schemas/Feedback'
              - $ref: '#/components/schemas/Impression'
              - $ref: '#/components/schemas/ViewableImpression'
              - $ref: '#/components/schemas/Click'
              - $ref: '#/components/schemas/HomePageView'
              - $ref: '#/components/schemas/CategoryPageView'
              - $ref: '#/components/schemas/PromoPageView'
              - $ref: '#/components/schemas/ProductImageView'
              - $ref: '#/components/schemas/Custom'
          default: []
        fl:
          title: Fl
          description: >

            List of fields to retrieve. For example, the following request
            retrieves only the `title` field of each product along

            with the `product_id`, which is always returned.


            ```

            {"fl": ["title"]}

            ```


            You can also match field names by using `*` as a wildcard. For
            example, the query below retrieves the `title`

            and any custom attributes under the `attributes` dictionary.


            ```

            {"fl": ["title", "attributes.*"]}

            ```


            The following retrieves all the available fields:


            ```

            {"fl": ["*"]}

            ```


            For the lowest latency, use an empty array to retrieve just the
            `product_id` field (which is the default).

            ```

            {"fl": []}

            ```
          type: array
          items:
            type: string
          default: []
        exclude:
          title: Exclude
          description: >-
            An array of `product_ids` of products you want to *exclude* from
            search results.
          type: array
          items:
            type: string
        q:
          title: Q
          description: >

            The search query the user has entered. Miso will perform full-text
            search and find any Products

            that contain every word in this query. You can also set `q="*"` to
            match all Products, which is commonly used along

            with Product filtering query `fq` to implement Category Pages.


            *(to make a search request, You need to specify either `q` or
            `advanced_q`)*
          minLength: 1
          type: string
        advanced_q:
          title: Advanced Q
          description: >

            Like Google's Advanced Search, the `advanced_q` parameter let you
            define query beyond simple full-text

            search. For one, you can use double-quotes to indicate a phrase
            search.


            For example, the following query will

            only match Products that contain the *phrase* "Toy Story 4", and
            will not match Products like "4 Toy Story"

            (because the word order is not the same as the given query).

            ```

            {"advanced_q": "full_text:\"Toy Story 4\""}

            ```


            If you don't want phrase search, you can enclose the search terms
            with parenthesis to indicate regular full-text query.

            For example:

            ```

            {"advanced_q": "full_text:(Toy Story 4)"}

            ```


            You can also use AND/OR boolean operators to combine multiple
            full-text queries. For example, the following query will match

            Products with phrases "Toy Story 4" and Products with phrases "Toy
            Story 3", and will not match "Toy Story 2" or "Toy Story 1":

            ```

            {"advanced_q":

            "full_text:\"Toy Story 4\" OR full_text:\"Toy Story 3\""}

            ```


            Finally, you can use AND/OR boolean operators to combine full-text
            search with metadata filtering.

            For example, the following example will find Products with phrase
            "Toy Story" OR Products which have Tom Hanks as an actor.

            ```

            {"advanced_q":

            "full_text:\"Toy Story\" OR
             custom_attributes.actors:\"Tom Hanks\""}
            ```


            *(to make a search request, You need to specify either `q` or
            `advanced_q`)*
          minLength: 1
          type: string
        boosting_tags:
          title: Boosting Tags
          description: >

            When `boosting_tags` is given, and there are pre-defined boost rules
            have the same tag(s),

            those boost rules will be matched, regardless if the criteria is met
            or not.


            Useful when want to force trigger specific boost campaign.
          type: array
          items:
            type: string
          default: []
          example:
            - tag-1
            - quetag-2
        enable_boosting_campaigns:
          title: Enable Boosting Campaigns
          description: >

            When set to true, enable user defined boosting campaigns.


            By default boosting campaigns are enabled. But you can explicitly
            set this to false to disable

            boosting campaigns.
          type: boolean
          default: true
        custom_context:
          title: Custom Context
          description: >

            Dictionary of custom context variables for the current browsing
            session. You can specify context variables

            specific to your websites or apps in a `{"KEY":VALUE}` format, where
            `KEY` must be a string, and `VALUE` can be:

            * a `bool`

            * a `string` or an `array of string`

            * a `number` or an `array of numbers`

            * an `array of objects`

            * `null`


            Miso will take these variables into account when generating
            recommendations.
          type: object
          example:
            session_variable_1:
              - value_1
              - value_2
        language:
          title: Language
          description: >

            Two-letter (639-1) language code of the search query. This parameter
            is useful when you have a multilingual
             product catalog that contains product metadata in different languages.
             If given, the search results will prioritize the products that have that specific language and match the search
              query. Example query:
            ```

            {"language": "fr"}

            ```


            If not given, Miso will search against all the languages in the
            catalog.
          type: string
        like:
          title: Like
          description: >-
            The text snippet that we want to find products that are similar to
            it
          type: string
        category:
          title: Category
          description: >

            `category` parameter limits the search results to a particular
            category or sub-category.

            This is particularly suitable for implementing Category Pages where

            you want to show personalized ranking of Products under a specific
            category. Other filters, such as `q`,

            `fq`, `boost_fq` will be applied on top of the category filter.


            A category is represented by a list of strings that correspond to
            its category hierarchy.

            For example, the following query returns Products under `Snacks`
            category:

            ```

            {
                "q": "*",
                "category": ["Snacks"]
            }

            ```

            And the following request returns Products under `Snacks -> Chips`
            subcategory:

            ```

            {
                "q": "*",
                "category": ["Snacks", "Chips"]
            }

            ```
          type: array
          items:
            type: string
        spellcheck:
          $ref: '#/components/schemas/SpellCheckRequest'
        start:
          title: Start
          description: >

            Specifies an offset from which Miso will begin returning results.


            The default value is `0`.  Setting the start parameter to some other
            number, such as 3, causes Miso to skip over the

            preceding products and start from the product identified by the
            offset.
          type: integer
          default: 0
        order_by:
          title: Order By
          description: >

            A list of fields that Miso should use to sort the result, instead of
            Miso's default ranking order.


            For example, the following query returns all the Products (because
            `q=*`), ranked by the `_personalization_score`

            first, and then by the values in the
            `custom_attributes.promote_score` field in the Product catalog, then
            the

            distance between the product and New York city.

            ```

            {
                "q": "*",
                "order_by": [
                    {
                        "field": "_personalization_score",
                        "tie_breaker": {
                            "type": "relative_difference",
                            "threshold": "0.05"
                        },
                        "order": "desc"
                    },
                    {
                        "field": "custom_attributes.promote_score",
                        "order": "desc"
                    },
                    {
                        "field": "_geo_distance",
                        "geo": {
                            "lat": 40.711967,
                            "lon": -74.006076,
                        }
                        "order": "asc"
                    }
                ]
            }

            ```
          type: array
          items:
            $ref: '#/components/schemas/OrderByDefinition'
          default: []
        facets:
          title: Facets
          description: >

            Specifies a list of fields to create facet search against. You can
            specify `facets` in a string array.

            For example, the following query return the facet counts for
            `categories`, `tags`, and `custom_attributes.director`:

            ```

            {
              "facets": [
                "categories",
                "tags",
                "custom_attributes.director"
              ]
            }

            ```


            The response will be like:

            ```

            {
              "facet_counts": {
                "facet_fields": {
                  "categories": [
                    [
                      "Drama", 20
                    ],
                    [
                      "Action", 10
                    ], ...
                  ],
                  "tags": [
                    [
                      "based on novel or book", 5
                    ],
                    [
                      "android", 4
                    ], ...
                  ],
                  "custom_attributes.director": [
                    [
                      "Ridley Scott", 26
                    ],
                    [
                      "Andrew Abbott", 1
                    ], ...
                }
              }
            ```


            You can also specify `facets` with an object array to configure each
            facet individually.

            For example, the following query will return 20 most common facet
            values for `tags`

            and `custom_attributes.director` fields,

            and only the directors whose names start with `Ridley` will be
            included in the director facet results.

            ```

            {
              "facets": [
                {
                  "field": "tags",
                  "size": 20
                },
                {
                  "field": "custom_attributes.director",
                  "size": 20,
                  "include": "Ridley.*"
                }
              ]
            }

            ```
          type: array
          items:
            anyOf:
              - $ref: '#/components/schemas/FacetDefinition'
              - type: string
          default: []
        facet_filters:
          title: Facet Filters
          description: >+

            Specifies filters to the search results based on users' selections
            in a faceted search UI.


            For example, assume you have two facets in your faceted search UI:
            `genres` and `custom_attributes.director`.

            When the user selects two options in the
            `custom_attributes.director` facet, you should send the following
            query to

            filter the search results for those two options (i.e. `Ridley Scott`
            or `Denis Villeneuve`).


            ```

            {
              "facets": [
                {
                  "field": "genres",
                  "size": 5
                },
                {
                  "field": "custom_attributes.director",
                  "size": 20
                }
              ],
              "facet_filters": {
                "custom_attributes.director": {
                  "terms": [
                    "Ridley Scott",
                    "Denis Villeneuve"
                  ]
                }
              },
            }

            ```


            While you can use `fq` parameter to achieve the same filtering
            capability,

            you should use `facet_filters` to get the correct facet counts.


            In a typical faceted search UI, the facet counts reflect the search
            result after applying

            filters from **all but the current facets**. For example, in the
            query below,

            the  *directors* facet counts
             should reflect the search result after applying the filter from the *genres* facet, i.e. `genres:Sci-Fi`.
             Similarly, *genres* facet counts should reflect the search result after applying the filter from the *directors* facet.

            `facet_filters` will make the resulting `facet_counts` follow this
            *all but except itself* convention, which is rather
             tricky to implement with `fq`.
            ```
              "facets": [
                {
                  "field": "genres",
                  "size": 5
                },
                {
                  "field": "custom_attributes.director",
                  "size": 20
                }
              ],
              "facet_filters": {
                "custom_attributes.director": {
                  "terms": [
                    "Ridley Scott",
                    "Denis Villeneuve"
                  ]
                }
              },
            }

            ```

          type: object
          additionalProperties:
            $ref: '#/components/schemas/Filter'
          default: {}
        anchoring_settings:
          title: Anchoring Settings
          description: >

            Promote a product to a position relative to the highest-ranked
            anchor product.


            A common use-case is promoting a private-label good by anchoring it
            to a name-brand counterpart. When the name-brand good (the anchor)
            appears in a search result, the private-label good also appears in
            the result (at a specified distance from the anchor product).


            The `anchoring_settings` object has the following fields:

            * **product_id** - The `product_id` of the product you want to
            promote.

            * **anchor_ids** - The array of `product_ids` that act as the
            anchors.

            * **relative_position** *(optional)* - The position that the
            promoted product will be returned in the search results, relative to
            the highest-ranked anchor product. For example, setting this
            parameter to `1` will place the promoted product directly after the
            anchor product. The default value is `-1`, which will place the
            promoted product directly before the anchor product.

            * **start_time** *(optional)* - An ISO-8601 timestamp indicating
            when to start the product anchoring. Ex: `2022-01-29T00:00:00Z`

            * **end_time** *(optional)* - An ISO-8601 timestamp indicating when
            to end the product anchoring. Ex: `2022-05-31T23:59:59Z`


            For example, if a user searches for "cookies", the API request might
            look like this:


            ```

            POST v1/search/search

            {
                "q":"cookies",
                "anchoring_settings": [
                 {
                     "product_id": "private_label_cookies",
                     "anchor_ids": [
                         "name_brand_cookies_1",
                         "name_brand_cookies_2"
                     ],
                     "relative_position": -1,
                     "start_time": "2022-01-01T00:00:00Z",
                     "end_time": "2022-12-31T23:59:59Z"
                     }
                 }
                ]
            }

            ```
          type: array
          items:
            $ref: '#/components/schemas/AnchoringEntry'
          default: []
        enable_partial_match:
          title: Enable Partial Match
          description: >

            Enable *partial match* to return products that match only *some* of
            the keywords in a user's search query. By default,

            Miso's Search API only returns products that contain *all* the
            keywords in the search query (i.e. an AND operator over

            keywords). This strategy usually leads to highly relevant results.
            However, when we don't have enough search results to

            return to the users, enabling partial match allows the Search API to
            relax the criteria and return products that match

            only some of the keywords.


            This strategy is particularly useful to prevent users from seeing an
            empty search result page and abandoning their

            search.


            For example, let's consider the query request below:

            ```

            {
              "query": "Toy story 5",
              "enable_partial_match": true
            }

            ```

            Since there is no movie called "Toy story 5", we have zero products
            to return by default. However, because we set `enable_partial_match`
            to `true`, we will return other products that partially match the
            query:

            ```

            {

            "data": {
                "products": [
                    {
                        "title": "Toy Story",
                        "_missing_keywords": ["5"]
                     },
                    {
                        "title": "Toy story 2",
                        "_missing_keywords": ["5"]
                    },
                    ...
                ],
                "total": 4
            }

            }

            ```

            As you can see from the result above, when we don't have the exact
            product that the user is looking for, enabling partial match is a
            helpful strategy to let users know what alternatives are available,
            and prevent them from seeing an empty search result page.
          type: boolean
          default: false
        partial_match_mode:
          title: Partial Match Mode
          description: >

            Determine which partial match mode to enable:
               * **blended** (default): When `partial_match_mode` is `blended`, keyword-matched items and semantically-matched items will
            be returned in the same, rank-sorted array.
               * **separated**: When `partial_match_mode` is `separated`, keyword-matched items will be returned in the `products` array
            and partially-matched or semantically-matched items will be returned
            in the `partially_matched_products` array.
          enum:
            - blended
            - separated
          default: blended
          type: string
        enable_partial_match_threshold:
          title: Enable Partial Match Threshold
          description: >

            If `partial_match_mode=separated`, you need to provide a value for
            `enable_partial_match_threshold`.

            This parameter, which accepts an integer (*n*), creates a condition
            for Miso’s Search Engine to only provide partially

            matched results if there are *n* or fewer exact keyword matches. For
            example, if we set `enable_partial_match_threshold=3`,

            partially matched results will *only* be returned when there are
            three or fewer exact keyword matches.
          type: integer
        enable_semantic_search:
          title: Enable Semantic Search
          description: >

            Enable *semantic search* to return products that are semantically
            relevant to the search query.

            Semantic search is a powerful tool that further improves the partial
            match results. It finds products that might not contain

            any of the search keywords, but are highly relevant to users' search
            intent.


            For example, consider the query: `rubbing alcohol`, which is a
            household cleaning product. When `enable_semantic_search=true`,

            even if we do not have any products that match `rubbing alcohol`,
            Miso is still able to return results like the

            following:

            ```

            {

            "data": {
                "products": [],
                "total": 0,
                "partially_matched_products": [
                    {
                        "title": "Clorox Disinfecting Wipes Multi-Surface Cleaning",
                        "_missing_keywords": ["rubbing", "alcohol"]
                     },
                    {
                        "title": "Purell Advanced Hand Sanitizer Refreshing Gel",
                        "_missing_keywords": ["rubbing", "alcohol"]
                    },
                    ...
                ]
            }

            }

            ```

            Note that, these two products from Clorox or Purell do not contain
            any of the search keywords,

            Miso's semantic search functionality, however, is still able to
            identify them as good matches based on their semantic

            relevancy to the query `rubbing alcohol`.


            Similarly, consider a single word search query: `aspirin`. Normally,
            a single-word query will lead to an empty search

            page if we don't have products containing that word. However, when
            `enable_semantic_search=true`,

            even if we do not directly have `aspirin` in the product catalog,
            Miso is still able to return results that are highly

            relevant to users' search intent, such as:

            ```

            {

            "data": {
                "products": [],
                "total": 0,
                "partially_matched_products": [
                    {
                        "title": "Advil Pain Reliever and Fever Reducer",
                        "_missing_keywords": ["aspirin"]
                     },
                    {
                        "title": "Tylenol Extra Strength Caplets",
                        "_missing_keywords": ["aspirin"]
                    },
                    ...
                ]
            }

            }

            ```
          type: boolean
          default: false
        semantic_search_threshold:
          title: Semantic Search Threshold
          description: >

            Determine the threshold for semantic search. Only the products with
            a semantic similarity score higher than the

            threshold will be returned. Setting this too low (e.g. < 0.3) will
            result in less relevant results being returned.
          type: number
          default: 0.5
        enable_matched_fields:
          title: Enable Matched Fields
          description: >+

            Determine whether to return `_matched_fields` in the search response
            (default: false).

            If `enable_matched_fields=true`,

            each returned product will have an `_matched_fields` array that
            shows which parts of the product catalog match
             the search query.

             For example, the following request will return `_matched_fields`:
            ```

            {
                "q": "toy story",
                "enable_matched_fields": true
            }

            ```

            The response will be like:

            ```

            {
                "data": {
                    "products": [
                        {
                            "title": "Toy Story",
                            "_matched_fields": ["title", "metadata"]
                         },
                         ...
                    ]
                }
            }

            ```

            Currently, `_matched_fields` only contain three kinds of fields:
               * `title`
               * `description`
               * `metadata`, including all the fields beyond title or description in the product catalog.

          type: boolean
          default: false
        query_product_existence:
          $ref: '#/components/schemas/CheckProductExistence'
        personalization_weight:
          title: Personalization Weight
          description: Determines how much personalization will affect the search ranking.
          maximum: 5
          minimum: 0
          type: integer
          default: 5
        fq:
          title: Fq
          description: >


            Defines a query in Solr syntax that can be used to restrict the
            superset of

            products to return, without influencing the overall ranking. `fq`
            can enable users to drill down to products

            with specific features based on different product attributes


            For example, the query below limits the search results to only show
            products whose size is either `M` or `S` and

            brand is `Nike`:


            ```

            {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

            ```


            You can use `fq` to apply filters against your custom attributes as
            well. For example, the query below limits the

            search results to only products whose `designer` attribute is
            `Calvin Klein`


            ```

            {"fq": "attributes.designer:\"Calvin Klein\""}

            ```


            `fq` can also limit search results by numerical range. For example,
            the following query limits the results to

            products that have `rating >= 4`.


            ```

            {"fq": "rating:[4 TO *]"}

            ```
          type: string
        boost_fq:
          title: Boost Fq
          description: >

            Defines a query in Solr syntax that can be used to boost a subset of
            products to the top of the ranking, or to

            specific *boost positions* (See `boost_positions` parameter below.)

            For example, the query below will promote all the relevant products
            whose brand is `Nike` to the top of

            recommendation list:


            ```

            {
                "boost_fq": "brand:\"Nike\""
            }

            ```


            For a slightly more complex example, the query below will promote
            the Nike products which have also been tagged

            as `ON SALE` to the top of the ranking:

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
            }

            ```

            It is worth mentioning that, Miso will only boost products that are
            relevant and have high likelihood to convert,

            and will not boost a low performance product only because it matches
            the boosting query.


            Depending on your boosting rules, in certain cases, you would like
            to prevent recommendation results from being

            too monotone due to boosting. With Miso, you have two tools to do
            so.


            First, you can specify `boost_positions` to place promoted products
            at specific positions in the ranking. For

            example, the query below will place boosted products only at the
            first and fourth places in the ranking

            (positions are 0-based), and place the remaining products in their
            original ranking, skipping these two positions.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "boost_positions": [0, 3]
            }

            ```


            The second tool is `diversification`. `diversification` parameter,
            on a best-effort basis, will try to

            maintain a minimum distance between products that have the same
            attributes. For example, the following query

            will place products made by the same brand apart from each other.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "diversification": {
                   "brand": {"minimum_distance": 1}
                }
            }

            ```
          type: string
        boost_positions:
          title: Boost Positions
          description: >

            Defines a list of 0-based positions you want to place the boosted
            products at.


            For example, the query below will promote products whose brand is
            `Nike` as the top and second recommendations:

            ```

            {
                "boost_fq": "brand:\"Nike\"",
                "boost_positions": [0, 1]
            }

            ```

            If `boost_positions` is not specified (which is the default
            behavior), all the boosted products will be ranked

            higher than the rest of the products.
          type: array
          items:
            type: integer
        boost_rules:
          title: Boost Rules
          description: >

            Define a list of boosting rules that will be applied to the search
            or recommendation results simultaneously. `boost_rules`

            parameter is particularly useful when you want to boost more than
            one sets of products, and promote each of them to different

            positions. For example, the query below will promote products whose
            brand is `Nike` to the top

            and second results, and products whose brand is `Adidas` to the
            third and fourth results:

            ```

            {
                "boost_rules": [
                    {
                        "boost_fq": "brand:\"Nike\"",
                        "boost_positions": [0, 1]
                    },
                    {
                        "boost_fq": "brand:\"Adidas\"",
                        "boost_positions": [2, 3]
                    }
                ]
            }

            ```
          type: array
          items:
            $ref: '#/components/schemas/BoostingFilterBase'
          default: []
        geo:
          $ref: '#/components/schemas/GeoQuery'
        diversification:
          title: Diversification
          description: >


            Defines diversification rules to prevent products with the same
            attributes (e.g. sneakers made by the same brand

            or books from the same authors) from showing up too close to each
            other in the results.


            For instance, customers who have purchased many of sneakers from
            Nike may happen to have recommendations or

            search results where all top-5 entries are sneakers made by Nike.
            Purely considering accuracy, these

            recommendations appear excellent since the user clearly appreciates
            Nike sneakers. However,

            such results might be considered too "plain" by the user, owing to
            its lack of diversity.


            `diversification` parameter allows you to avoid this problem by
            enforcing a desired *minimum distance* between

            products. For example, consider a list of four products whose
            `brand` are *Nike, Nike, Adidas,* and *PUMA*

            respectively. The query below will make sure there are at least one
            different product between two Nike

            products, e.g. the diversified ranking may become *Nike, Adidas,
            Nike,* and *PUMA* :

            ```

            {
               "diversification": {"brand": {"minimum_distance": 1}}
            }

            ```


            You can also increase the minimum_distance to place products further
            apart. For example, the following query will

            make sure, for the two Nike products, there are at least *two* other
            products between them.

            As a result, the diversified ranking may become *Nike, Adidas,
            PUMA*, and *Nike*.:

            ```

            {
               "diversification": {"brand": {"minimum_distance": 2}}
            }

            ```


            The diversification algorithm reranks the products on a best-effort
            basis. For example, for the product list

            described earlier, it is not possible to place two Nike product
            three places apart from each other. Therefore,

            the diversified ranking will still remain *Nike, Adidas, PUMA,* and
            Nike* even if we set `minimum_distance=3`.
          type: object
          additionalProperties:
            $ref: '#/components/schemas/DiversifyField'
      x-konfig-properties:
        spellcheck:
          title: Spellcheck
          description: Spellcheck configuration
          default:
            enable_auto_spelling_correction: true
        query_product_existence:
          title: Query Product Existence
          description: >-
            Additionally check if certain products will be in the search result
            at all (regardless of `start` and `rows` parameters)
        geo:
          title: Geo
          description: >

            When set, filter result to include only products within certain
            geographic range from given point will be returned,

            or to boost product within the same range.


            Product should have a field that holds the location of the product,
            `location` is used by default,

            but other field can also be used.


            Distance can be in miles or kilometers. If `distance_unit` is not
            set, `mile` will be used.


            For example, to limit results to products within 100 miles of New
            York city:

            ```

            {
                "geo": {
                    "filter": [{
                        "lat": 40.73061,
                        "lon": -73.93524,
                        "distance": 100
                    }]
                }
            }

            ```


            To boost products within 2 kilometers around Alcatraz Island
            according to `loc` field:

            ```

            {
                "geo": {
                    "boost": [{
                        "field": "loc",
                        "lat": 37.82667,
                        "lon": -122.42278,
                        "distance": 2,
                        "distance_unit": "km"
                    }]
                }
            }

            ```
    SearchResponse:
      title: SearchResponse
      required:
        - data
      type: object
      properties:
        message:
          title: Message
          type: string
          default: success
        data:
          $ref: '#/components/schemas/SearchResponseBody'
    SearchResponseBody:
      title: SearchResponseBody
      required:
        - products
        - total
        - start
        - spellcheck
      type: object
      properties:
        took:
          title: Took
          description: Number of milliseconds Miso took to retrieve the results.
          type: integer
          default: 0
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          default: 00000000-0000-0000-0000-000000000000
          example: 123e4567-e89b-12d3-a456-426614174000
        products:
          title: Products
          description: The search results.
          type: array
          items:
            $ref: '#/components/schemas/PartialMatchedRecord'
        total:
          title: Total
          description: Total number of search hits.
          type: integer
          example: 1000
        start:
          title: Start
          description: Starting offset of the search results.
          type: integer
          example: 0
        spellcheck:
          $ref: '#/components/schemas/SpellCheckResponse'
        product_existence:
          title: Product Existence
          description: Product existence query result
          type: object
          additionalProperties:
            type: boolean
        partially_matched_products:
          title: Partially Matched Products
          description: The search results that only partially match the search query.
          type: array
          items:
            $ref: '#/components/schemas/PartialMatchedRecord'
        facet_counts:
          $ref: '#/components/schemas/FacetCounts'
        custom_assets:
          title: Custom Assets
          description: Custom JSON assets uploaded in Dojo.
          type: array
          items:
            type: object
          default: []
      x-konfig-properties:
        spellcheck:
          title: Spellcheck
          description: >-
            Spellcheck results. You can use the information in this object to
            prompt users with the correct spelling.
        facet_counts:
          title: Facet Counts
          description: Facet counts
          default: {}
    SendExperimentResponse:
      title: SendExperimentResponse
      required:
        - took
        - in_experiment
        - variant
      type: object
      properties:
        took:
          title: Took
          description: >-
            The amount of time (in milliseconds) Miso took to answer this
            request.
          type: integer
          example: 50
        in_experiment:
          title: In Experiment
          description: To show whether the experiment is active or not.
          type: boolean
        variant:
          $ref: '#/components/schemas/VariantObject'
    Share:
      title: share
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: |

            Used when a user shares a product or piece of content.
          enum:
            - share
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    SpellCheckRequest:
      title: SpellCheckRequest
      type: object
      properties:
        enable_auto_spelling_correction:
          title: Enable Auto Spelling Correction
          description: >

            This parameter controls whether to automatically correct a misspell
            search query.

            If set to `true`, when Miso detects spelling errors, the search
            results will be based on the
             **corrected** spelling suggested by Miso.

            You call tell if Miso made any correction to the search query by
            checking the

            `spellcheck.auto_spelling_correction` field in the

            API response. When this field is `true`, the search results are
            based on the suggested spelling

            as opposed to the users' original query.


            You can opt-out the spelling correction by setting this parameter to
            `false`. In such cases,

            Miso will still detect spelling errors,

            but the search results will be always based on users' original
            spelling.
          type: boolean
          default: true
    SpellCheckResponse:
      title: SpellCheckResponse
      required:
        - spelling_errors
        - auto_spelling_correction
        - original_query
        - original_query_with_markups
        - corrected_query
        - corrected_query_with_markups
      type: object
      properties:
        spelling_errors:
          title: Spelling Errors
          description: Whether Miso detects any spelling errors.
          type: boolean
        auto_spelling_correction:
          title: Auto Spelling Correction
          description: >-
            Whether Miso has automatically corrected the misspelled search
            query. When this field is `true`, the search result is based on the
            corrected spelling in the `corrected_query` field instead of users'
            original search query.
          type: boolean
        original_query:
          title: Original Query
          description: Original query string
          type: string
          example: what is pythn
        original_query_with_markups:
          title: Original Query With Markups
          description: >-
            Original query with the spelling errors (if any) surrounded by the
            <mark> tags
          type: string
          example: what is <mark>pythn</mark>
        corrected_query:
          title: Corrected Query
          description: >-
            The corrected spelling suggested by Miso. If no spelling error is
            detected, this will be the same as `original_query`
          type: string
          example: what is python
        corrected_query_with_markups:
          title: Corrected Query With Markups
          description: >-
            The corrected spelling suggested by Miso where the revised tokens
            are surrounded by the <mark> tags.
          type: string
          example: what is <mark>python</mark>
    Subscribe:
      title: subscribe
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            Used when a user subscribes a product, for example to receive alerts
            when the product comes back in stock or if the price drops.
          enum:
            - subscribe
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    TaskId:
      title: TaskId
      required:
        - task_id
      type: object
      properties:
        task_id:
          title: Task Id
          type: string
    TieBreakDefinition:
      title: TieBreakDefinition
      type: object
      properties:
        type:
          title: Type
          enum:
            - relative_difference
          default: relative_difference
          type: string
        threshold:
          title: Threshold
          type: number
          default: 0
    TitleCompletion:
      title: TitleCompletion
      description: title completion additionally has the `product` the title belongs to.
      required:
        - text
        - text_with_markups
        - text_with_inverted_markups
        - product
      type: object
      properties:
        text:
          title: Text
          minLength: 1
          type: string
          example: Japanese Shiba Inu Dog Eating Miso Soup T-Shirt
        text_with_markups:
          title: Text With Markups
          minLength: 1
          type: string
          example: Japanese<mark> Shiba Inu Dog Eating Miso Soup T-Shirt</mark>
        text_with_inverted_markups:
          title: Text With Inverted Markups
          minLength: 1
          type: string
          example: <mark>Japanese</mark> Shiba Inu Dog Eating Miso Soup T-Shirt
        product:
          $ref: '#/components/schemas/Record'
      x-konfig-properties:
        product:
          title: Product
          example:
            product_id: 123ABC-S-Black
    TrendRecResponse:
      title: TrendRecResponse
      required:
        - data
      type: object
      properties:
        message:
          title: Message
          type: string
          default: success
        data:
          $ref: '#/components/schemas/TrendResponseBody'
    TrendResponseBody:
      title: TrendResponseBody
      required:
        - products
      type: object
      properties:
        took:
          title: Took
          description: Number of milliseconds Miso took to retrieve the results.
          type: integer
          default: 0
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          default: 00000000-0000-0000-0000-000000000000
          example: 123e4567-e89b-12d3-a456-426614174000
        products:
          title: Products
          description: Trending product results.
          type: array
          items:
            $ref: '#/components/schemas/Record'
    UserBulkDeleteIn:
      title: UserBulkDeleteIn
      required:
        - data
      type: object
      properties:
        data:
          $ref: '#/components/schemas/UserIdList'
    UserBulkIn:
      title: UserBulkIn
      required:
        - data
      type: object
      properties:
        data:
          title: Data
          type: array
          items:
            $ref: '#/components/schemas/UserRecord'
    UserIdList:
      title: UserIdList
      required:
        - user_ids
      type: object
      properties:
        user_ids:
          title: User Ids
          type: array
          items:
            type: string
    UserReadOut:
      title: UserReadOut
      required:
        - message
        - data
      type: object
      properties:
        message:
          title: Message
          description: Human-readable message
          type: string
          example: success
        data:
          $ref: '#/components/schemas/UserRecord'
    UserRecord:
      title: UserRecord
      required:
        - user_id
      type: object
      properties:
        description:
          title: Description
          description: >

            Text description of the user. This can be the user's own bio or the
            internal notes about the user. If available,

            Miso will analyze this description to better profile a user.  
          type: string
          example: Engineer from Northwind Corp
        user_id:
          title: User Id
          description: >

            Unique identifier for a user who has signed in. `user_id` can be in
            any format (e.g. users' email, internal user

            UUID or serial ID). The only restriction is that the first character
            must not be an underline `_`. Miso will use 

            this id to cross-reference your User records with your Interaction
            records.
          maxLength: 512
          minLength: 1
          type: string
          example: user_1234
        created_at:
          title: Created At
          description: >

            The date the user’s account was created as an ISO-8601 date or
            datetime string. 
          anyOf:
            - type: string
              format: date-time
            - type: string
              format: date
        updated_at:
          title: Updated At
          description: >

            The date the user’s account was updated as an ISO-8601 date or
            datetime string. 
          anyOf:
            - type: string
              format: date-time
            - type: string
              format: date
        name:
          title: Name
          description: The user's full name.
          type: string
          example: John Doe
        profile_image:
          title: Profile Image
          description: URL to the profile image of the user.
          maxLength: 65536
          minLength: 1
          type: string
          format: uri
        age:
          title: Age
          description: Age of the user. We will internally convert it to year of birth.
          type: integer
          example: 33
        gender:
          title: Gender
          description: The user's gender.
          type: string
          example: M
        city:
          title: City
          description: City or zipcode the user is based in.
          type: string
          example: Mountain View
        state:
          title: State
          description: State the user is based in.
          type: string
          example: California
        country:
          title: Country
          description: Country the user is based in.
          type: string
          example: US
        group_id:
          title: Group Id
          description: >

            Group or Account ID from your CRM. This is useful in B2B scenarios.
            For example, you can use `group_id` to 

            associate a user with their company or account. We will use this
            information to infer the user's interests and 

            fine-tune their personalization and search results. For example,
            users from the same group might have similar 

            interests on the site, and we can improve their user experience
            accordingly
          type: string
          example: Northwind Corp
        custom_attributes:
          title: Custom Attributes
          description: >

            Dictionary of custom attributes about the user. As with the [Product
            API](#operation/content_write_api_v1_products_post), you can specify
            attributes specific to your business in a `{"KEY" : VALUE}` format,
            where `KEY` must be a string, and
             `VALUE` can be:
            * a `string` or `an array of strings`

            * a `number` or `an array of numbers`

            * an `array of objects`

            * a `bool`

            * `null` 


            * Example:

            ```

            {
                "custom_attributes": {
                    "acquisition_channel": "Facebook Campaign 2020",
                    "declared_interests": ["Drama", "Romance"]
                }
            }

            ```

            These custom attributes types must be consistent across all User
            records in your data set. 

            Records with inconsistent types will fail to be inserted.
          type: object
          additionalProperties:
            anyOf:
              - type: boolean
              - type: integer
              - type: number
              - type: string
              - type: array
                items:
                  type: number
              - type: array
                items:
                  type: string
              - type: array
                items:
                  type: object
                  additionalProperties:
                    anyOf:
                      - type: string
                      - type: number
                      - type: integer
                      - type: boolean
          example:
            acquisition_channel: Facebook Campaign 2020
            declared_interests:
              - Drama
              - Romance
    UserToAttributes:
      title: UserToAttributes
      description: >-
        User to attributes recommendations. Given a user, recommend

        product attributes the user will be interested in as well as products in
        those attributes
      required:
        - field
      type: object
      properties:
        boosting_tags:
          title: Boosting Tags
          description: >

            When `boosting_tags` is given, and there are pre-defined boost rules
            have the same tag(s),

            those boost rules will be matched, regardless if the criteria is met
            or not.


            Useful when want to force trigger specific boost campaign.
          type: array
          items:
            type: string
          default: []
          example:
            - tag-1
            - quetag-2
        field:
          title: Field
          description: >


            The attribute you want to make recommendations for. For example, the
            following

            query will recommend values from the `brand` field that Miso thinks
            the user will be interested in:


            ```

            {"field": "brand"}

            ```


            This API also works for custom attributes you define. For example,

            if you provide a `designer` custom attribute, then, you can make
            `designer` recommendations with the following query.

            ```

            {"field": "custom_attributes.designer"}

            ```
          type: string
        boost_attributes:
          title: Boost Attributes
          description: |+


            The attributes to boost to the top of the recommendations

          type: array
          items:
            type: string
          default: []
        exclude_attributes:
          title: Exclude Attributes
          description: |+


            The attributes to remove from the recommendations

          type: array
          items:
            type: string
          default: []
        rows:
          title: Rows
          description: Number of product recommendations to return
          type: integer
          default: 5
        products_per_attribute:
          title: Products Per Attribute
          description: >

            Number of personalized product recommendations to make for **each**
            recommended attribute. For example, the following

            query will return 5 products for each *brand* we recommend:

            ```

            {
                "field": "brand",
                "products_per_attribute": 2
            }

            ```


            Note that a large number of `products_per_attribute` will increase
            latency slightly because we need to

            perform more computation for each of the recommended attributes. If
            you only need attribute

            recommendations, you can set

            `products_per_attribute=0` to reduce latency.
          type: integer
          default: 2
        engine_id:
          title: Engine Id
          description: >

            The engine you want to get results from. When you have more than one
            engine, you can use this parameter to

            specify the specific engine you want to get results from. If not
            specified, the default engine will be used.
          type: string
        user_id:
          title: User Id
          description: >

            The user who made the query and for whom Miso will personalize the
            results. For an anonymous visitor, use `anonymous_id` instead.
          type: string
        anonymous_id:
          title: Anonymous Id
          description: >-
            The anonymous visitor who made the query and for whom Miso will
            personalize the results. Either
                    `user_id` or `anonymous_id` needs to be specified for personalization to work. 
          type: string
        user_hash:
          title: User Hash
          description: >

            The hash of `user_id` (or `anonymous_id`) encrypted by your [Secret
            API Key](https://api.askmiso.com).

            `user_hash` is required to prevent unauthorized API access if you
            are

            making API calls with a [Publishable API
            Key](https://api.askmiso.com).


            You should generate the user_hash via HMAC scheme: you encrypt the
            desired user_id (or anonymous_id) with your

            [Secret API Key](https://api.askmiso.com) on your backend server,

            and then let the front-end code send the generated user_hash to Miso
            APIs to

            verify the identity of the API caller.


            As long as the [Secret API Key](https://api.askmiso.com)
             is kept secret, the user_hash prevents a malicious attacker from making unauthorized
            API calls or impersonating any of your users.


            Miso APIs accept the case-incentive "hex digest" of user hash, a
            sample Python 3 code to generate it on your backend server

            is as follow:


            ```python

            import hashlib

            import hmac


            YOUR_MISO_SECRET_API_KEY = "039c501ac8dfcac91"

            key_bytes = YOUR_MISO_SECRET_API_KEY.encode()

            user_id = "USER_123" # or anonymous_id

            user_id_bytes = user_id.encode()

            user_hash = hmac.new(
                key_bytes,
                user_id_bytes,
                hashlib.sha256).hexdigest()
            # user_hash is "7eb04da5e..."

            ```


            You can find more examples for other languages in this [Github
            Gist](https://gist.github.com/thewheat/7342c76ade46e7322c3e)
          type: string
        user_cohort:
          title: User Cohort
          description: >

            The user cohort you want to cold-start the recommendation with. For
            example, the following query will make

            recommendations based on the preferences of the users whose
            `country="United States"`, and `gender="Female"`

            in the User Profile dataset.

            ```

            {
                "user_cohort": {
                    "country": "United States",
                    "gender": "Female"
                }
            }

            ```
          type: object
          additionalProperties:
            anyOf:
              - type: boolean
              - type: string
        type:
          title: Type
          description: >

            The type of products to return. Use this parameter to make the API
            return only

            a certain type of products (see [Product
            APIs](https://api.askmiso.com)).


            This is particularly useful for sites that have multiple types of
            products:

            For example, on a marketplace site, YOu may model *merchandise* and
            *store* as two types of *products*. You can

            then use type parameter to limit the recommendation or search
            results to return only one kind of them.


            For instance, the following query will return only *store* products:
             ```
            {"type": "store"}
             ```

            For another example, on a travel website, you might have: *hotel*,
            *thing to do*, and *restaurant*,

            three kinds

            of products. You can use `type` parameter to limit results to one
            kind of them. For instance, the following

            query will limit the results to only *hotels* product:
             ```
            {"type": "hotel"}
             ```
          type: string
        dedupe_product_group_id:
          title: Dedupe Product Group Id
          description: >

            Whether to dedupe product based on `product_group_id`. If
            `dedupe_product_group_id=true`,

            Miso will prevent products with the same `product_group_id` from
            showing multiple

            times in the search or recommendation results.



            This is particular useful when one product has multiple variants
            (for example, different

            sizes, colors, or materials), and you only want to show this product
            only once in the search or recommendation

            results. Miso will then return the variant that is most likely to be
            of the user's interest.
          type: boolean
          default: true
        additional_interactions:
          title: Additional Interactions
          description: >

            A list of additional interaction records. You can use this fields to
            simulate user interactions without

            actually writing them to the interaction dataset.
          type: array
          items:
            anyOf:
              - $ref: '#/components/schemas/ProductDetailPageView'
              - $ref: '#/components/schemas/Search'
              - $ref: '#/components/schemas/AddToCart'
              - $ref: '#/components/schemas/RemoveFromCart'
              - $ref: '#/components/schemas/Checkout'
              - $ref: '#/components/schemas/Refund'
              - $ref: '#/components/schemas/Subscribe'
              - $ref: '#/components/schemas/AddToCollection'
              - $ref: '#/components/schemas/RemoveFromCollection'
              - $ref: '#/components/schemas/Read'
              - $ref: '#/components/schemas/Watch'
              - $ref: '#/components/schemas/Listen'
              - $ref: '#/components/schemas/Like'
              - $ref: '#/components/schemas/Dislike'
              - $ref: '#/components/schemas/Share'
              - $ref: '#/components/schemas/Rate'
              - $ref: '#/components/schemas/Bookmark'
              - $ref: '#/components/schemas/Complete'
              - $ref: '#/components/schemas/Feedback'
              - $ref: '#/components/schemas/Impression'
              - $ref: '#/components/schemas/ViewableImpression'
              - $ref: '#/components/schemas/Click'
              - $ref: '#/components/schemas/HomePageView'
              - $ref: '#/components/schemas/CategoryPageView'
              - $ref: '#/components/schemas/PromoPageView'
              - $ref: '#/components/schemas/ProductImageView'
              - $ref: '#/components/schemas/Custom'
          default: []
        fl:
          title: Fl
          description: >

            List of fields to retrieve. For example, the following request
            retrieves only the `title` field of each product along

            with the `product_id`, which is always returned.


            ```

            {"fl": ["title"]}

            ```


            You can also match field names by using `*` as a wildcard. For
            example, the query below retrieves the `title`

            and any custom attributes under the `attributes` dictionary.


            ```

            {"fl": ["title", "attributes.*"]}

            ```


            The following retrieves all the available fields:


            ```

            {"fl": ["*"]}

            ```


            For the lowest latency, use an empty array to retrieve just the
            `product_id` field (which is the default).

            ```

            {"fl": []}

            ```
          type: array
          items:
            type: string
          default: []
        exclude:
          title: Exclude
          description: >-
            An array of `product_ids` of products you want to *exclude* from
            search results.
          type: array
          items:
            type: string
        fq:
          title: Fq
          description: >


            Defines a query in Solr syntax that can be used to restrict the
            superset of

            products to return, without influencing the overall ranking. `fq`
            can enable users to drill down to products

            with specific features based on different product attributes


            For example, the query below limits the search results to only show
            products whose size is either `M` or `S` and

            brand is `Nike`:


            ```

            {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

            ```


            You can use `fq` to apply filters against your custom attributes as
            well. For example, the query below limits the

            search results to only products whose `designer` attribute is
            `Calvin Klein`


            ```

            {"fq": "attributes.designer:\"Calvin Klein\""}

            ```


            `fq` can also limit search results by numerical range. For example,
            the following query limits the results to

            products that have `rating >= 4`.


            ```

            {"fq": "rating:[4 TO *]"}

            ```
          type: string
        boost_fq:
          title: Boost Fq
          description: >

            Defines a query in Solr syntax that can be used to boost a subset of
            products to the top of the ranking, or to

            specific *boost positions* (See `boost_positions` parameter below.)

            For example, the query below will promote all the relevant products
            whose brand is `Nike` to the top of

            recommendation list:


            ```

            {
                "boost_fq": "brand:\"Nike\""
            }

            ```


            For a slightly more complex example, the query below will promote
            the Nike products which have also been tagged

            as `ON SALE` to the top of the ranking:

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
            }

            ```

            It is worth mentioning that, Miso will only boost products that are
            relevant and have high likelihood to convert,

            and will not boost a low performance product only because it matches
            the boosting query.


            Depending on your boosting rules, in certain cases, you would like
            to prevent recommendation results from being

            too monotone due to boosting. With Miso, you have two tools to do
            so.


            First, you can specify `boost_positions` to place promoted products
            at specific positions in the ranking. For

            example, the query below will place boosted products only at the
            first and fourth places in the ranking

            (positions are 0-based), and place the remaining products in their
            original ranking, skipping these two positions.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "boost_positions": [0, 3]
            }

            ```


            The second tool is `diversification`. `diversification` parameter,
            on a best-effort basis, will try to

            maintain a minimum distance between products that have the same
            attributes. For example, the following query

            will place products made by the same brand apart from each other.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "diversification": {
                   "brand": {"minimum_distance": 1}
                }
            }

            ```
          type: string
        boost_positions:
          title: Boost Positions
          description: >

            Defines a list of 0-based positions you want to place the boosted
            products at.


            For example, the query below will promote products whose brand is
            `Nike` as the top and second recommendations:

            ```

            {
                "boost_fq": "brand:\"Nike\"",
                "boost_positions": [0, 1]
            }

            ```

            If `boost_positions` is not specified (which is the default
            behavior), all the boosted products will be ranked

            higher than the rest of the products.
          type: array
          items:
            type: integer
        boost_rules:
          title: Boost Rules
          description: >

            Define a list of boosting rules that will be applied to the search
            or recommendation results simultaneously. `boost_rules`

            parameter is particularly useful when you want to boost more than
            one sets of products, and promote each of them to different

            positions. For example, the query below will promote products whose
            brand is `Nike` to the top

            and second results, and products whose brand is `Adidas` to the
            third and fourth results:

            ```

            {
                "boost_rules": [
                    {
                        "boost_fq": "brand:\"Nike\"",
                        "boost_positions": [0, 1]
                    },
                    {
                        "boost_fq": "brand:\"Adidas\"",
                        "boost_positions": [2, 3]
                    }
                ]
            }

            ```
          type: array
          items:
            $ref: '#/components/schemas/BoostingFilterBase'
          default: []
        geo:
          $ref: '#/components/schemas/GeoQuery'
      x-konfig-properties:
        geo:
          title: Geo
          description: >

            When set, filter result to include only products within certain
            geographic range from given point will be returned,

            or to boost product within the same range.


            Product should have a field that holds the location of the product,
            `location` is used by default,

            but other field can also be used.


            Distance can be in miles or kilometers. If `distance_unit` is not
            set, `mile` will be used.


            For example, to limit results to products within 100 miles of New
            York city:

            ```

            {
                "geo": {
                    "filter": [{
                        "lat": 40.73061,
                        "lon": -73.93524,
                        "distance": 100
                    }]
                }
            }

            ```


            To boost products within 2 kilometers around Alcatraz Island
            according to `loc` field:

            ```

            {
                "geo": {
                    "boost": [{
                        "field": "loc",
                        "lat": 37.82667,
                        "lon": -122.42278,
                        "distance": 2,
                        "distance_unit": "km"
                    }]
                }
            }

            ```
    UserToCategories:
      title: UserToCategories
      description: Attributes for recommendation boosting
      type: object
      properties:
        engine_id:
          title: Engine Id
          description: >

            The engine you want to get results from. When you have more than one
            engine, you can use this parameter to

            specify the specific engine you want to get results from. If not
            specified, the default engine will be used.
          type: string
        user_id:
          title: User Id
          description: >

            The user who made the query and for whom Miso will personalize the
            results. For an anonymous visitor, use `anonymous_id` instead.
          type: string
        anonymous_id:
          title: Anonymous Id
          description: >-
            The anonymous visitor who made the query and for whom Miso will
            personalize the results. Either
                    `user_id` or `anonymous_id` needs to be specified for personalization to work. 
          type: string
        user_hash:
          title: User Hash
          description: >

            The hash of `user_id` (or `anonymous_id`) encrypted by your [Secret
            API Key](https://api.askmiso.com).

            `user_hash` is required to prevent unauthorized API access if you
            are

            making API calls with a [Publishable API
            Key](https://api.askmiso.com).


            You should generate the user_hash via HMAC scheme: you encrypt the
            desired user_id (or anonymous_id) with your

            [Secret API Key](https://api.askmiso.com) on your backend server,

            and then let the front-end code send the generated user_hash to Miso
            APIs to

            verify the identity of the API caller.


            As long as the [Secret API Key](https://api.askmiso.com)
             is kept secret, the user_hash prevents a malicious attacker from making unauthorized
            API calls or impersonating any of your users.


            Miso APIs accept the case-incentive "hex digest" of user hash, a
            sample Python 3 code to generate it on your backend server

            is as follow:


            ```python

            import hashlib

            import hmac


            YOUR_MISO_SECRET_API_KEY = "039c501ac8dfcac91"

            key_bytes = YOUR_MISO_SECRET_API_KEY.encode()

            user_id = "USER_123" # or anonymous_id

            user_id_bytes = user_id.encode()

            user_hash = hmac.new(
                key_bytes,
                user_id_bytes,
                hashlib.sha256).hexdigest()
            # user_hash is "7eb04da5e..."

            ```


            You can find more examples for other languages in this [Github
            Gist](https://gist.github.com/thewheat/7342c76ade46e7322c3e)
          type: string
        user_cohort:
          title: User Cohort
          description: >

            The user cohort you want to cold-start the recommendation with. For
            example, the following query will make

            recommendations based on the preferences of the users whose
            `country="United States"`, and `gender="Female"`

            in the User Profile dataset.

            ```

            {
                "user_cohort": {
                    "country": "United States",
                    "gender": "Female"
                }
            }

            ```
          type: object
          additionalProperties:
            anyOf:
              - type: boolean
              - type: string
        rows:
          title: Rows
          description: Number of recommended categories to return
          type: integer
          default: 5
        type:
          title: Type
          description: >

            The type of products to return. Use this parameter to make the API
            return only

            a certain type of products (see [Product
            APIs](https://api.askmiso.com)).


            This is particularly useful for sites that have multiple types of
            products:

            For example, on a marketplace site, YOu may model *merchandise* and
            *store* as two types of *products*. You can

            then use type parameter to limit the recommendation or search
            results to return only one kind of them.


            For instance, the following query will return only *store* products:
             ```
            {"type": "store"}
             ```

            For another example, on a travel website, you might have: *hotel*,
            *thing to do*, and *restaurant*,

            three kinds

            of products. You can use `type` parameter to limit results to one
            kind of them. For instance, the following

            query will limit the results to only *hotels* product:
             ```
            {"type": "hotel"}
             ```
          type: string
        dedupe_product_group_id:
          title: Dedupe Product Group Id
          description: >

            Whether to dedupe product based on `product_group_id`. If
            `dedupe_product_group_id=true`,

            Miso will prevent products with the same `product_group_id` from
            showing multiple

            times in the search or recommendation results.



            This is particular useful when one product has multiple variants
            (for example, different

            sizes, colors, or materials), and you only want to show this product
            only once in the search or recommendation

            results. Miso will then return the variant that is most likely to be
            of the user's interest.
          type: boolean
          default: true
        additional_interactions:
          title: Additional Interactions
          description: >

            A list of additional interaction records. You can use this fields to
            simulate user interactions without

            actually writing them to the interaction dataset.
          type: array
          items:
            anyOf:
              - $ref: '#/components/schemas/ProductDetailPageView'
              - $ref: '#/components/schemas/Search'
              - $ref: '#/components/schemas/AddToCart'
              - $ref: '#/components/schemas/RemoveFromCart'
              - $ref: '#/components/schemas/Checkout'
              - $ref: '#/components/schemas/Refund'
              - $ref: '#/components/schemas/Subscribe'
              - $ref: '#/components/schemas/AddToCollection'
              - $ref: '#/components/schemas/RemoveFromCollection'
              - $ref: '#/components/schemas/Read'
              - $ref: '#/components/schemas/Watch'
              - $ref: '#/components/schemas/Listen'
              - $ref: '#/components/schemas/Like'
              - $ref: '#/components/schemas/Dislike'
              - $ref: '#/components/schemas/Share'
              - $ref: '#/components/schemas/Rate'
              - $ref: '#/components/schemas/Bookmark'
              - $ref: '#/components/schemas/Complete'
              - $ref: '#/components/schemas/Feedback'
              - $ref: '#/components/schemas/Impression'
              - $ref: '#/components/schemas/ViewableImpression'
              - $ref: '#/components/schemas/Click'
              - $ref: '#/components/schemas/HomePageView'
              - $ref: '#/components/schemas/CategoryPageView'
              - $ref: '#/components/schemas/PromoPageView'
              - $ref: '#/components/schemas/ProductImageView'
              - $ref: '#/components/schemas/Custom'
          default: []
        fl:
          title: Fl
          description: >

            List of fields to retrieve. For example, the following request
            retrieves only the `title` field of each product along

            with the `product_id`, which is always returned.


            ```

            {"fl": ["title"]}

            ```


            You can also match field names by using `*` as a wildcard. For
            example, the query below retrieves the `title`

            and any custom attributes under the `attributes` dictionary.


            ```

            {"fl": ["title", "attributes.*"]}

            ```


            The following retrieves all the available fields:


            ```

            {"fl": ["*"]}

            ```


            For the lowest latency, use an empty array to retrieve just the
            `product_id` field (which is the default).

            ```

            {"fl": []}

            ```
          type: array
          items:
            type: string
          default: []
        exclude:
          title: Exclude
          description: >-
            An array of `product_ids` of products you want to *exclude* from
            search results.
          type: array
          items:
            type: string
        boosting_tags:
          title: Boosting Tags
          description: >

            When `boosting_tags` is given, and there are pre-defined boost rules
            have the same tag(s),

            those boost rules will be matched, regardless if the criteria is met
            or not.


            Useful when want to force trigger specific boost campaign.
          type: array
          items:
            type: string
          default: []
          example:
            - tag-1
            - quetag-2
        products_per_category:
          title: Products Per Category
          description: >-


            Number of products to return for **each** category. For example, the
            following

            query will return 5 products for each category we recommend:

            ```

            {"products": 5}

            ```

            Note that, a large number of `products_per_category` (say >= 20)
            will increase query latency (up to around 200ms)

            because we need to perform more computation for each of the
            recommended categories. If you

            only need category recommendations, you should set
            `products_per_category` to 0 to reduce latency.
          type: integer
          default: 5
        root_category:
          title: Root Category
          description: >-

            If `root_category` is specified, we will only recommend categories
            that are direct children of each of the root

            category. For example, the following query will recommend the
            products of category that is under `["Clothes"]` category:

            ```

            {"root_category": ["Clothes"]}

            ```

            For another example, the following query will recommend the products
            of category that is under `["Clothes", "Dresses"]` category

            ```

            {"root_category": ["Clothes", "Dresses"]}

            ```

            If `root_category` is not specified, we will recommend the *top
            level* categories. 
          type: array
          items:
            type: string
          default: []
        fq:
          title: Fq
          description: >


            Defines a query in Solr syntax that can be used to restrict the
            superset of

            products to return, without influencing the overall ranking. `fq`
            can enable users to drill down to products

            with specific features based on different product attributes


            For example, the query below limits the search results to only show
            products whose size is either `M` or `S` and

            brand is `Nike`:


            ```

            {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

            ```


            You can use `fq` to apply filters against your custom attributes as
            well. For example, the query below limits the

            search results to only products whose `designer` attribute is
            `Calvin Klein`


            ```

            {"fq": "attributes.designer:\"Calvin Klein\""}

            ```


            `fq` can also limit search results by numerical range. For example,
            the following query limits the results to

            products that have `rating >= 4`.


            ```

            {"fq": "rating:[4 TO *]"}

            ```
          type: string
        boost_fq:
          title: Boost Fq
          description: >

            Defines a query in Solr syntax that can be used to boost a subset of
            products to the top of the ranking, or to

            specific *boost positions* (See `boost_positions` parameter below.)

            For example, the query below will promote all the relevant products
            whose brand is `Nike` to the top of

            recommendation list:


            ```

            {
                "boost_fq": "brand:\"Nike\""
            }

            ```


            For a slightly more complex example, the query below will promote
            the Nike products which have also been tagged

            as `ON SALE` to the top of the ranking:

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
            }

            ```

            It is worth mentioning that, Miso will only boost products that are
            relevant and have high likelihood to convert,

            and will not boost a low performance product only because it matches
            the boosting query.


            Depending on your boosting rules, in certain cases, you would like
            to prevent recommendation results from being

            too monotone due to boosting. With Miso, you have two tools to do
            so.


            First, you can specify `boost_positions` to place promoted products
            at specific positions in the ranking. For

            example, the query below will place boosted products only at the
            first and fourth places in the ranking

            (positions are 0-based), and place the remaining products in their
            original ranking, skipping these two positions.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "boost_positions": [0, 3]
            }

            ```


            The second tool is `diversification`. `diversification` parameter,
            on a best-effort basis, will try to

            maintain a minimum distance between products that have the same
            attributes. For example, the following query

            will place products made by the same brand apart from each other.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "diversification": {
                   "brand": {"minimum_distance": 1}
                }
            }

            ```
          type: string
        boost_positions:
          title: Boost Positions
          description: >

            Defines a list of 0-based positions you want to place the boosted
            products at.


            For example, the query below will promote products whose brand is
            `Nike` as the top and second recommendations:

            ```

            {
                "boost_fq": "brand:\"Nike\"",
                "boost_positions": [0, 1]
            }

            ```

            If `boost_positions` is not specified (which is the default
            behavior), all the boosted products will be ranked

            higher than the rest of the products.
          type: array
          items:
            type: integer
        boost_rules:
          title: Boost Rules
          description: >

            Define a list of boosting rules that will be applied to the search
            or recommendation results simultaneously. `boost_rules`

            parameter is particularly useful when you want to boost more than
            one sets of products, and promote each of them to different

            positions. For example, the query below will promote products whose
            brand is `Nike` to the top

            and second results, and products whose brand is `Adidas` to the
            third and fourth results:

            ```

            {
                "boost_rules": [
                    {
                        "boost_fq": "brand:\"Nike\"",
                        "boost_positions": [0, 1]
                    },
                    {
                        "boost_fq": "brand:\"Adidas\"",
                        "boost_positions": [2, 3]
                    }
                ]
            }

            ```
          type: array
          items:
            $ref: '#/components/schemas/BoostingFilterBase'
          default: []
        geo:
          $ref: '#/components/schemas/GeoQuery'
      x-konfig-properties:
        geo:
          title: Geo
          description: >

            When set, filter result to include only products within certain
            geographic range from given point will be returned,

            or to boost product within the same range.


            Product should have a field that holds the location of the product,
            `location` is used by default,

            but other field can also be used.


            Distance can be in miles or kilometers. If `distance_unit` is not
            set, `mile` will be used.


            For example, to limit results to products within 100 miles of New
            York city:

            ```

            {
                "geo": {
                    "filter": [{
                        "lat": 40.73061,
                        "lon": -73.93524,
                        "distance": 100
                    }]
                }
            }

            ```


            To boost products within 2 kilometers around Alcatraz Island
            according to `loc` field:

            ```

            {
                "geo": {
                    "boost": [{
                        "field": "loc",
                        "lat": 37.82667,
                        "lon": -122.42278,
                        "distance": 2,
                        "distance_unit": "km"
                    }]
                }
            }

            ```
    UserToItemsRequest:
      title: UserToItemsRequest
      description: Attributes for recommendation boosting
      type: object
      properties:
        engine_id:
          title: Engine Id
          description: >

            The engine you want to get results from. When you have more than one
            engine, you can use this parameter to

            specify the specific engine you want to get results from. If not
            specified, the default engine will be used.
          type: string
        user_id:
          title: User Id
          description: >

            The user who made the query and for whom Miso will personalize the
            results. For an anonymous visitor, use `anonymous_id` instead.
          type: string
        anonymous_id:
          title: Anonymous Id
          description: >-
            The anonymous visitor who made the query and for whom Miso will
            personalize the results. Either
                    `user_id` or `anonymous_id` needs to be specified for personalization to work. 
          type: string
        user_hash:
          title: User Hash
          description: >

            The hash of `user_id` (or `anonymous_id`) encrypted by your [Secret
            API Key](https://api.askmiso.com).

            `user_hash` is required to prevent unauthorized API access if you
            are

            making API calls with a [Publishable API
            Key](https://api.askmiso.com).


            You should generate the user_hash via HMAC scheme: you encrypt the
            desired user_id (or anonymous_id) with your

            [Secret API Key](https://api.askmiso.com) on your backend server,

            and then let the front-end code send the generated user_hash to Miso
            APIs to

            verify the identity of the API caller.


            As long as the [Secret API Key](https://api.askmiso.com)
             is kept secret, the user_hash prevents a malicious attacker from making unauthorized
            API calls or impersonating any of your users.


            Miso APIs accept the case-incentive "hex digest" of user hash, a
            sample Python 3 code to generate it on your backend server

            is as follow:


            ```python

            import hashlib

            import hmac


            YOUR_MISO_SECRET_API_KEY = "039c501ac8dfcac91"

            key_bytes = YOUR_MISO_SECRET_API_KEY.encode()

            user_id = "USER_123" # or anonymous_id

            user_id_bytes = user_id.encode()

            user_hash = hmac.new(
                key_bytes,
                user_id_bytes,
                hashlib.sha256).hexdigest()
            # user_hash is "7eb04da5e..."

            ```


            You can find more examples for other languages in this [Github
            Gist](https://gist.github.com/thewheat/7342c76ade46e7322c3e)
          type: string
        user_cohort:
          title: User Cohort
          description: >

            The user cohort you want to cold-start the recommendation with. For
            example, the following query will make

            recommendations based on the preferences of the users whose
            `country="United States"`, and `gender="Female"`

            in the User Profile dataset.

            ```

            {
                "user_cohort": {
                    "country": "United States",
                    "gender": "Female"
                }
            }

            ```
          type: object
          additionalProperties:
            anyOf:
              - type: boolean
              - type: string
        rows:
          title: Rows
          description: Number of product recommendations to return
          type: integer
          default: 5
        type:
          title: Type
          description: >

            The type of products to return. Use this parameter to make the API
            return only

            a certain type of products (see [Product
            APIs](https://api.askmiso.com)).


            This is particularly useful for sites that have multiple types of
            products:

            For example, on a marketplace site, YOu may model *merchandise* and
            *store* as two types of *products*. You can

            then use type parameter to limit the recommendation or search
            results to return only one kind of them.


            For instance, the following query will return only *store* products:
             ```
            {"type": "store"}
             ```

            For another example, on a travel website, you might have: *hotel*,
            *thing to do*, and *restaurant*,

            three kinds

            of products. You can use `type` parameter to limit results to one
            kind of them. For instance, the following

            query will limit the results to only *hotels* product:
             ```
            {"type": "hotel"}
             ```
          type: string
        dedupe_product_group_id:
          title: Dedupe Product Group Id
          description: >

            Whether to dedupe product based on `product_group_id`. If
            `dedupe_product_group_id=true`,

            Miso will prevent products with the same `product_group_id` from
            showing multiple

            times in the search or recommendation results.



            This is particular useful when one product has multiple variants
            (for example, different

            sizes, colors, or materials), and you only want to show this product
            only once in the search or recommendation

            results. Miso will then return the variant that is most likely to be
            of the user's interest.
          type: boolean
          default: true
        additional_interactions:
          title: Additional Interactions
          description: >

            A list of additional interaction records. You can use this fields to
            simulate user interactions without

            actually writing them to the interaction dataset.
          type: array
          items:
            anyOf:
              - $ref: '#/components/schemas/ProductDetailPageView'
              - $ref: '#/components/schemas/Search'
              - $ref: '#/components/schemas/AddToCart'
              - $ref: '#/components/schemas/RemoveFromCart'
              - $ref: '#/components/schemas/Checkout'
              - $ref: '#/components/schemas/Refund'
              - $ref: '#/components/schemas/Subscribe'
              - $ref: '#/components/schemas/AddToCollection'
              - $ref: '#/components/schemas/RemoveFromCollection'
              - $ref: '#/components/schemas/Read'
              - $ref: '#/components/schemas/Watch'
              - $ref: '#/components/schemas/Listen'
              - $ref: '#/components/schemas/Like'
              - $ref: '#/components/schemas/Dislike'
              - $ref: '#/components/schemas/Share'
              - $ref: '#/components/schemas/Rate'
              - $ref: '#/components/schemas/Bookmark'
              - $ref: '#/components/schemas/Complete'
              - $ref: '#/components/schemas/Feedback'
              - $ref: '#/components/schemas/Impression'
              - $ref: '#/components/schemas/ViewableImpression'
              - $ref: '#/components/schemas/Click'
              - $ref: '#/components/schemas/HomePageView'
              - $ref: '#/components/schemas/CategoryPageView'
              - $ref: '#/components/schemas/PromoPageView'
              - $ref: '#/components/schemas/ProductImageView'
              - $ref: '#/components/schemas/Custom'
          default: []
        fl:
          title: Fl
          description: >

            List of fields to retrieve. For example, the following request
            retrieves only the `title` field of each product along

            with the `product_id`, which is always returned.


            ```

            {"fl": ["title"]}

            ```


            You can also match field names by using `*` as a wildcard. For
            example, the query below retrieves the `title`

            and any custom attributes under the `attributes` dictionary.


            ```

            {"fl": ["title", "attributes.*"]}

            ```


            The following retrieves all the available fields:


            ```

            {"fl": ["*"]}

            ```


            For the lowest latency, use an empty array to retrieve just the
            `product_id` field (which is the default).

            ```

            {"fl": []}

            ```
          type: array
          items:
            type: string
          default: []
        exclude:
          title: Exclude
          description: >-
            An array of `product_ids` of products you want to *exclude* from
            search results.
          type: array
          items:
            type: string
        boosting_tags:
          title: Boosting Tags
          description: >

            When `boosting_tags` is given, and there are pre-defined boost rules
            have the same tag(s),

            those boost rules will be matched, regardless if the criteria is met
            or not.


            Useful when want to force trigger specific boost campaign.
          type: array
          items:
            type: string
          default: []
          example:
            - tag-1
            - quetag-2
        fq:
          title: Fq
          description: >


            Defines a query in Solr syntax that can be used to restrict the
            superset of

            products to return, without influencing the overall ranking. `fq`
            can enable users to drill down to products

            with specific features based on different product attributes


            For example, the query below limits the search results to only show
            products whose size is either `M` or `S` and

            brand is `Nike`:


            ```

            {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

            ```


            You can use `fq` to apply filters against your custom attributes as
            well. For example, the query below limits the

            search results to only products whose `designer` attribute is
            `Calvin Klein`


            ```

            {"fq": "attributes.designer:\"Calvin Klein\""}

            ```


            `fq` can also limit search results by numerical range. For example,
            the following query limits the results to

            products that have `rating >= 4`.


            ```

            {"fq": "rating:[4 TO *]"}

            ```
          type: string
        boost_fq:
          title: Boost Fq
          description: >

            Defines a query in Solr syntax that can be used to boost a subset of
            products to the top of the ranking, or to

            specific *boost positions* (See `boost_positions` parameter below.)

            For example, the query below will promote all the relevant products
            whose brand is `Nike` to the top of

            recommendation list:


            ```

            {
                "boost_fq": "brand:\"Nike\""
            }

            ```


            For a slightly more complex example, the query below will promote
            the Nike products which have also been tagged

            as `ON SALE` to the top of the ranking:

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
            }

            ```

            It is worth mentioning that, Miso will only boost products that are
            relevant and have high likelihood to convert,

            and will not boost a low performance product only because it matches
            the boosting query.


            Depending on your boosting rules, in certain cases, you would like
            to prevent recommendation results from being

            too monotone due to boosting. With Miso, you have two tools to do
            so.


            First, you can specify `boost_positions` to place promoted products
            at specific positions in the ranking. For

            example, the query below will place boosted products only at the
            first and fourth places in the ranking

            (positions are 0-based), and place the remaining products in their
            original ranking, skipping these two positions.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "boost_positions": [0, 3]
            }

            ```


            The second tool is `diversification`. `diversification` parameter,
            on a best-effort basis, will try to

            maintain a minimum distance between products that have the same
            attributes. For example, the following query

            will place products made by the same brand apart from each other.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "diversification": {
                   "brand": {"minimum_distance": 1}
                }
            }

            ```
          type: string
        boost_positions:
          title: Boost Positions
          description: >

            Defines a list of 0-based positions you want to place the boosted
            products at.


            For example, the query below will promote products whose brand is
            `Nike` as the top and second recommendations:

            ```

            {
                "boost_fq": "brand:\"Nike\"",
                "boost_positions": [0, 1]
            }

            ```

            If `boost_positions` is not specified (which is the default
            behavior), all the boosted products will be ranked

            higher than the rest of the products.
          type: array
          items:
            type: integer
        boost_rules:
          title: Boost Rules
          description: >

            Define a list of boosting rules that will be applied to the search
            or recommendation results simultaneously. `boost_rules`

            parameter is particularly useful when you want to boost more than
            one sets of products, and promote each of them to different

            positions. For example, the query below will promote products whose
            brand is `Nike` to the top

            and second results, and products whose brand is `Adidas` to the
            third and fourth results:

            ```

            {
                "boost_rules": [
                    {
                        "boost_fq": "brand:\"Nike\"",
                        "boost_positions": [0, 1]
                    },
                    {
                        "boost_fq": "brand:\"Adidas\"",
                        "boost_positions": [2, 3]
                    }
                ]
            }

            ```
          type: array
          items:
            $ref: '#/components/schemas/BoostingFilterBase'
          default: []
        geo:
          $ref: '#/components/schemas/GeoQuery'
        diversification:
          title: Diversification
          description: >


            Defines diversification rules to prevent products with the same
            attributes (e.g. sneakers made by the same brand

            or books from the same authors) from showing up too close to each
            other in the results.


            For instance, customers who have purchased many of sneakers from
            Nike may happen to have recommendations or

            search results where all top-5 entries are sneakers made by Nike.
            Purely considering accuracy, these

            recommendations appear excellent since the user clearly appreciates
            Nike sneakers. However,

            such results might be considered too "plain" by the user, owing to
            its lack of diversity.


            `diversification` parameter allows you to avoid this problem by
            enforcing a desired *minimum distance* between

            products. For example, consider a list of four products whose
            `brand` are *Nike, Nike, Adidas,* and *PUMA*

            respectively. The query below will make sure there are at least one
            different product between two Nike

            products, e.g. the diversified ranking may become *Nike, Adidas,
            Nike,* and *PUMA* :

            ```

            {
               "diversification": {"brand": {"minimum_distance": 1}}
            }

            ```


            You can also increase the minimum_distance to place products further
            apart. For example, the following query will

            make sure, for the two Nike products, there are at least *two* other
            products between them.

            As a result, the diversified ranking may become *Nike, Adidas,
            PUMA*, and *Nike*.:

            ```

            {
               "diversification": {"brand": {"minimum_distance": 2}}
            }

            ```


            The diversification algorithm reranks the products on a best-effort
            basis. For example, for the product list

            described earlier, it is not possible to place two Nike product
            three places apart from each other. Therefore,

            the diversified ranking will still remain *Nike, Adidas, PUMA,* and
            Nike* even if we set `minimum_distance=3`.
          type: object
          additionalProperties:
            $ref: '#/components/schemas/DiversifyField'
        pagination_id:
          title: Pagination Id
          description: >

            A unique identifier to enable pagination in Recommendation APIs. By
            default, Recommendation APIs do not support

            pagination because the results from Miso, by its natural, will
            change in real-time with new user interactions.

            `pagination_id` allows you to implement pagination more easily by
            memorize what products we have

            returned to the current user with the same `pagination_id`.


            To enable pagination, you generate a `pagination_id` and set it in
            the first and subsequent requests in the same browsing session

            where you want to enable pagination. With `pagination_id` set, you
            can access recommendations

            in different pages using the combination of `start` and `rows`
            parameters, and Miso will ensure that no duplicated

            recommendation will be returned in different pages.


            For example, assuming you are implementing an infinite scroll with
            Miso Recommendation APIs. Before you make the first request,

            you generate a `pagination_id` using the `current datetime` or
            `uuid` like the following:

            ```javascript

            // current datetime

            var my_pagination_id = Date.now().toString()

            // OR uuid

            const uuidv4 = require("uuid/v4")

            var my_pagination_id = uuidv4()

            ```

            You can then request the first page of results with
            `my_pagination_id` like the following:

            ```javascript

            {
                "pagination_id": my_pagination_id,
                "start": 0,
                "rows": 10
            }

            ```

            Then, you can request the next page of results with the same
            `my_pagination_id`, and Miso will ensure

            that no duplicated result is returned:

            ```javascript

            {
                "pagination_id": my_pagination_id,
                "start": 10,
                "rows": 10
            }

            ```


            Note that, a `pagination_id` will timeout if there is no further
            request associated with it for 30 minutes.

            Also, `pagination_id` is scoped by individual users: i.e. different
            users' results will not be affected

            even if they use the same `pagination_id`.
          maxLength: 512
          type: string
        start:
          title: Start
          description: >

            The start of the page you want to access. Combine this with `rows`
            to implement pagination. You can only set it when `pagination_id` is
            given.
          type: integer
          default: 0
      x-konfig-properties:
        geo:
          title: Geo
          description: >

            When set, filter result to include only products within certain
            geographic range from given point will be returned,

            or to boost product within the same range.


            Product should have a field that holds the location of the product,
            `location` is used by default,

            but other field can also be used.


            Distance can be in miles or kilometers. If `distance_unit` is not
            set, `mile` will be used.


            For example, to limit results to products within 100 miles of New
            York city:

            ```

            {
                "geo": {
                    "filter": [{
                        "lat": 40.73061,
                        "lon": -73.93524,
                        "distance": 100
                    }]
                }
            }

            ```


            To boost products within 2 kilometers around Alcatraz Island
            according to `loc` field:

            ```

            {
                "geo": {
                    "boost": [{
                        "field": "loc",
                        "lat": 37.82667,
                        "lon": -122.42278,
                        "distance": 2,
                        "distance_unit": "km"
                    }]
                }
            }

            ```
    ValidationError:
      title: ValidationError
      required:
        - loc
        - msg
        - type
      type: object
      properties:
        loc:
          title: Location
          type: array
          items:
            type: string
        msg:
          title: Message
          type: string
        type:
          title: Error Type
          type: string
    VariantObject:
      title: VariantObject
      required:
        - id
        - name
        - slug
        - status
      type: object
      properties:
        id:
          title: Id
          description: The UUID of this variant.
          type: string
          example: 59769b89-5f1f-46d5-a4fa-a583ebd2f7fd
        name:
          title: Name
          description: The name of this variant.
          type: string
          example: Treatment_Group
        slug:
          title: Slug
          description: The slug name of this variant.
          type: string
          example: Treatment_Group
        configuration:
          title: Configuration
          description: The configuration of this variant.
          anyOf:
            - type: object
            - type: array
              items: {}
            - type: string
          example:
            model: A
        status:
          title: Status
          description: The current status for this variant.
          enum:
            - Draft
            - Scheduled
            - Active
            - Completed
            - Archived
          type: string
          example: Active
    ViewableImpression:
      title: viewable_impression
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            When a product or content asset is presented to the user, it is not
            guarantee that the user will see it.


            An viewable impression is an impression that is "viewable" by the
            user.

            Usually, content asset is considered viewable if more than 50% of
            its area is visible on screen.


            You can also use different definition for what is considered
            viewable.

            Miso will automatically find the best recommendation as long as the
            difference between

            viewable and non-viewable impression is consistant.
          enum:
            - viewable_impression
          type: string
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    Watch:
      title: watch
      required:
        - type
      type: object
      properties:
        type:
          title: Type
          description: >

            Used to record when and for how long a user watches content that is
            of a video format.
          enum:
            - watch
          type: string
        duration:
          title: Duration
          description: >

            How long (in seconds) the user stayed on this page, or consumed
            (listened, read, or watched) a product. This field is

            optional, but it's very important in scenarios where consumption
            duration matters, including

            `product_detail_page_view`, `category_page_view`, `watch`, `listen`,
            and `read`. For example, if a user only

            views or consumes a product for less than 5 seconds, that user is
            probably not interested in the product. On

            the other hand, if a user stays on a page for a while, it usually
            means they are seriously engaging with or

            considering the product. When `duration` is absent, we will use the
            timestamp of the next interaction to

            infer a rough duration value.


            Example:

            ```

            {"duration": 61.5}

            ```
          type: number
          example: 61.5
        product_ids:
          title: Product Ids
          description: >

            Products or content the user is interacting with. This field is
            required by

            almost all the interaction types. We use `product_ids` to refer to
            the product / content records that you upload to Miso.

            Therefore, it is important to keep this consistent between the two
            datasets.


            Example:

            ```

            {"product_ids": ["123ABC-BLACK", "123EFG-YELLOW"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          default: []
          example:
            - 123ABC-BLACK
        product_group_ids:
          title: Product Group Ids
          description: >

            The product groups the user is interacting with. You only need this
            field if you model product

            variants using `product_id` and `product_group_id` (see Product
            API). If so, you should use this field, when a

            user is interacting with a *product group* rather than a specific
            product variant, for example, when the user

            is viewing the master page of a T-shirt (i.e. a product group), but
            has not selected the specific size or

            color (i.e. a product variant) yet.


            In such situations, the `product_id` is not applicable because we
            only know the user is interested in

            this T-shirt (a product group), but don't know which particular
            product variant the user is interested in.

            Therefore, we use `product_group_ids` to capture such interactions
            in place of `product_ids`.


            In the situations where specific `product_ids` are available, for
            example, when user selected a particular size

            of the T-Shirt, use `product_ids` instead.



            Example:

            ```

            {"product_group_ids": ["123ABC"]}

            ```
          type: array
          items:
            type: string
            maxLength: 512
          example:
            - 123ABC
        user_id:
          title: User Id
          description: >-
            Identifies the signed-in user who performed the interaction. We will
            use `user_id` to link Interaction records to your
                    User records. Therefore, it is important to keep this consistent between the two datasets.For visitors who have
                    not signed in, see `anonymous_id`.
          maxLength: 512
          type: string
          example: user_1234
        anonymous_id:
          title: Anonymous Id
          description: >-
            A pseudo-unique substitute for the User Id. We use `anonymous_id` to
            identify a visitor who has not signed
                    in. `anonymous_id` can be implemented using mechanisms such as cookies or browser localStorage. If `anonymous_id`
                    is not given, we will default it to `SHA1(<API key>:<IP address>:<user agent>:<date>)`. When a visitor signs
                    in and the `user_id` and `anonymous_id` are both present, the `anonymous_id` will be linked to the `user_id`
                    along with the past interactions associated with it.
          maxLength: 1024
          type: string
          example: 86D51273AD8BF84217E1567B6CBE7152D7034404
        timestamp:
          title: Timestamp
          description: >

            The ISO-8601 timestamp specifying when the interaction occurred. If
            the interaction just happened, leave it out and we

            will default to the server's time. If you're importing data from the
            past, make sure you provide a

            timestamp. It is recommended to include milliseconds in the
            timestamp to provide a higher time resolution.


            Example:

            ```

            {"timestamp": "2018-11-07T00:25:00.073876Z"}

            ```
          type: string
          format: date-time
        miso_id:
          title: Miso Id
          description: >

            Miso-generated unique Id for each recommendation or search result.
            Maintaining this Id for

            subsequent page views is important to Miso's performance, as we use
            `miso_id` to track and fine-tune the

            performance of personalization and search results. When a user
            clicks on a recommendation or search result,

            you should pass the associated `miso_id` to the next page view, and
            associate the `miso_id` with the

            interactions that take place on the page (e.g.
            `product_detail_page_view`, `add_to_cart`,

            `add_to_collection`, `like`, etc.). In this way, Miso will learn
            which recommendations work and which didn't.


            Example:

            ```

            {"misoId": "123e4567-e89b-12d3-a456-426614174000"}

            ```
          type: string
          format: uuid
          example: 123e4567-e89b-12d3-a456-426614174000
        context:
          $ref: '#/components/schemas/WebBasedContext'
      x-konfig-properties:
        context:
          title: Context
          description: >

            Dictionary of extra information that provides useful context about
            an interaction. We use context

            information to make recommendations tailored not only for each user,
            but also for their current browsing context.

            For example, a user browsing on a desktop may have different
            browsing behavior than a user browsing on mobile

            phone. As another example, a user who gets to the site via a certain
            campaign you run on Facebook may have very

            different interests than a user who visits your site directly.


            Context information is also useful for personalization for entirely
            new visitors, as we can immediately

            personalize their experiences based on their context alone (e.g. the
            referrer or the campaign they clicked through).


            Example:

            ```

            {"context": {
                "campaign":
                {
                    "name": "spring_sale",
                    "source": "Google",
                    "medium": "cpc",
                    "term": "running+shoes",
                    "content": "textlink"
                },
                "truncated_ip": "1.1.1.0",
                "locale": "en-US",
                "region": "US East",
                "page":
                    {
                        "url": "https://example.com/miso-tshirt-123ABC",
                        "referrer": "https://example.com/",
                        "title": "My Product Page"
                    },
                    "user_agent": "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0)"
                },
                "custom_context": {
                    "other_context_var_1": "value_1",
                    "other_context_var_2": "value_2"
                }
            }

            ```
    WebBasedContext:
      title: WebBasedContext
      type: object
      properties:
        campaign:
          $ref: '#/components/schemas/Campaign'
        truncated_ip:
          title: Truncated Ip
          description: >

            User's truncated IP address. We use IP address to determine the
            country of the users.
          type: string
          format: ipv4
          example: 1.1.1.0
        locale:
          title: Locale
          description: Locale string of the current session, for example en-US.
          type: string
          example: en-US
        region:
          title: Region
          description: >

            The region/location of the site the user is visiting. This is for
            sites that serve different regions or

            markets. You can define your own region keywords, for example, `US
            East`, `Europe`, `LATM`, etc.
          type: string
          example: US East
        page:
          $ref: '#/components/schemas/Page'
        user_agent:
          title: User Agent
          description: >

            User agent of the device making the request. We use this to
            determine if a user is browsing the site on

            mobile or desktop, and tailor the recommendations and search results
            accordingly.


            Example:

            ```

            {"user_agent":
                "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0"}
            ```
          type: string
          example: >-
            Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101
            Firefox/47.0
        custom_context:
          title: Custom Context
          description: >

            Dictionary of custom context variables for the current browsing
            session. You can specify context variables

            specific to your websites or apps in a `{"KEY":VALUE}` format, where
            `KEY` must be a string, and `VALUE` can be:

            * a `bool`

            * a `string` or an `array of string`

            * a `number` or an `array of numbers`

            * an `array of objects`

            * `null`


            Miso will take these variables into account when generating
            recommendations.
          type: object
          additionalProperties:
            anyOf:
              - type: boolean
              - type: integer
              - type: number
              - type: string
              - type: array
                items:
                  type: number
              - type: array
                items:
                  type: string
              - type: array
                items:
                  type: object
                  additionalProperties:
                    anyOf:
                      - type: string
                      - type: number
                      - type: integer
                      - type: boolean
          example:
            session_variable_1:
              - value_1
              - value_2
      x-konfig-properties:
        campaign:
          title: Campaign
          description: >

            The campaign that resulted in the interaction. Campaign dictionary
            contains standard UTM parameters: `name`,

            `source`, `medium`, `term`, `content`. We use campaign information
            to infer users' interests and fine-tune the

            personalization and search results based on the current user's
            campaign information.
        page:
          title: Page
          description: >-
            The current page in the browser. Page dictionary containing
            referrer, title and url. we will use page view
                    as a pseudo interaction to infer users' interest. 
    YMALRequest:
      title: YMALRequest
      description: Attributes for recommendation boosting
      type: object
      properties:
        product_id:
          title: Product Id
          description: >

            The `product_id` of the *anchor* product. The returned
            recommendations will be

            the products that are similar or are liked by the same users who
            also like the anchor product.
          minLength: 1
          type: string
        product_ids:
          title: Product Ids
          description: >

            The `product_ids` of a **list** of *anchor* products. The returned
            recommendations will be

            the products that are similar or are liked by the same users who
            also like these anchor products. For example,

            you can use the products in a user's shopping cart as the anchor
            products to make purchase recommendations

            for this user.
          minLength: 1
          type: array
          items:
            type: string
            minLength: 1
        product_group_id:
          title: Product Group Id
          description: >

            The `product_group_id` of the *anchor* product group. The returned
            recommendations will be

            the products that are similar or are liked by the same users who
            also like the anchor *product group*.


            You should use `product_group_id` on a *product

            group* page, before users select a specific product variant. For
            example, you should use `product_group_id`

            on the product group page of a T-shirt, and use `product_id`, once
            user choose any specific size or color

            variants of the T-shirt.
          minLength: 1
          type: string
        product_group_ids:
          title: Product Group Ids
          description: >

            The `product_group_ids` of the *anchor* product groups. The returned
            recommendations will be

            the products that are similar or are liked by the same users who
            also like the anchor *product groups*.


            You should use `product_group_ids` in pages you want to recommend
            products related to multiple product groups.
          type: array
          items:
            type: string
        buy_together:
          title: Buy Together
          description: >+

            Whether to focus on the Products that are frequently *bought
            together*. `buy_together` parameter is by default `false`,

            which make the *Product To Products API* focus on Products that are
            related to the anchor products, e.g. the products

            with similar contents or frequently attract the interests of the
            same group of users.


            When `buy_together=true`, the ProductToProducts API will focus on
            the type of Products that are more frequently bought

            together along with the anchor product(s) in the same transactions
            or session.

          type: boolean
          default: false
        engine_id:
          title: Engine Id
          description: >

            The engine you want to get results from. When you have more than one
            engine, you can use this parameter to

            specify the specific engine you want to get results from. If not
            specified, the default engine will be used.
          type: string
        user_id:
          title: User Id
          description: >

            The user who made the query and for whom Miso will personalize the
            results. For an anonymous visitor, use `anonymous_id` instead.
          type: string
        anonymous_id:
          title: Anonymous Id
          description: >-
            The anonymous visitor who made the query and for whom Miso will
            personalize the results. Either
                    `user_id` or `anonymous_id` needs to be specified for personalization to work. 
          type: string
        user_hash:
          title: User Hash
          description: >

            The hash of `user_id` (or `anonymous_id`) encrypted by your [Secret
            API Key](https://api.askmiso.com).

            `user_hash` is required to prevent unauthorized API access if you
            are

            making API calls with a [Publishable API
            Key](https://api.askmiso.com).


            You should generate the user_hash via HMAC scheme: you encrypt the
            desired user_id (or anonymous_id) with your

            [Secret API Key](https://api.askmiso.com) on your backend server,

            and then let the front-end code send the generated user_hash to Miso
            APIs to

            verify the identity of the API caller.


            As long as the [Secret API Key](https://api.askmiso.com)
             is kept secret, the user_hash prevents a malicious attacker from making unauthorized
            API calls or impersonating any of your users.


            Miso APIs accept the case-incentive "hex digest" of user hash, a
            sample Python 3 code to generate it on your backend server

            is as follow:


            ```python

            import hashlib

            import hmac


            YOUR_MISO_SECRET_API_KEY = "039c501ac8dfcac91"

            key_bytes = YOUR_MISO_SECRET_API_KEY.encode()

            user_id = "USER_123" # or anonymous_id

            user_id_bytes = user_id.encode()

            user_hash = hmac.new(
                key_bytes,
                user_id_bytes,
                hashlib.sha256).hexdigest()
            # user_hash is "7eb04da5e..."

            ```


            You can find more examples for other languages in this [Github
            Gist](https://gist.github.com/thewheat/7342c76ade46e7322c3e)
          type: string
        user_cohort:
          title: User Cohort
          description: >

            The user cohort you want to cold-start the recommendation with. For
            example, the following query will make

            recommendations based on the preferences of the users whose
            `country="United States"`, and `gender="Female"`

            in the User Profile dataset.

            ```

            {
                "user_cohort": {
                    "country": "United States",
                    "gender": "Female"
                }
            }

            ```
          type: object
          additionalProperties:
            anyOf:
              - type: boolean
              - type: string
        rows:
          title: Rows
          description: Number of product recommendations to return
          type: integer
          default: 5
        type:
          title: Type
          description: >

            The type of products to return. Use this parameter to make the API
            return only

            a certain type of products (see [Product
            APIs](https://api.askmiso.com)).


            This is particularly useful for sites that have multiple types of
            products:

            For example, on a marketplace site, YOu may model *merchandise* and
            *store* as two types of *products*. You can

            then use type parameter to limit the recommendation or search
            results to return only one kind of them.


            For instance, the following query will return only *store* products:
             ```
            {"type": "store"}
             ```

            For another example, on a travel website, you might have: *hotel*,
            *thing to do*, and *restaurant*,

            three kinds

            of products. You can use `type` parameter to limit results to one
            kind of them. For instance, the following

            query will limit the results to only *hotels* product:
             ```
            {"type": "hotel"}
             ```
          type: string
        dedupe_product_group_id:
          title: Dedupe Product Group Id
          description: >

            Whether to dedupe product based on `product_group_id`. If
            `dedupe_product_group_id=true`,

            Miso will prevent products with the same `product_group_id` from
            showing multiple

            times in the search or recommendation results.



            This is particular useful when one product has multiple variants
            (for example, different

            sizes, colors, or materials), and you only want to show this product
            only once in the search or recommendation

            results. Miso will then return the variant that is most likely to be
            of the user's interest.
          type: boolean
          default: true
        additional_interactions:
          title: Additional Interactions
          description: >

            A list of additional interaction records. You can use this fields to
            simulate user interactions without

            actually writing them to the interaction dataset.
          type: array
          items:
            anyOf:
              - $ref: '#/components/schemas/ProductDetailPageView'
              - $ref: '#/components/schemas/Search'
              - $ref: '#/components/schemas/AddToCart'
              - $ref: '#/components/schemas/RemoveFromCart'
              - $ref: '#/components/schemas/Checkout'
              - $ref: '#/components/schemas/Refund'
              - $ref: '#/components/schemas/Subscribe'
              - $ref: '#/components/schemas/AddToCollection'
              - $ref: '#/components/schemas/RemoveFromCollection'
              - $ref: '#/components/schemas/Read'
              - $ref: '#/components/schemas/Watch'
              - $ref: '#/components/schemas/Listen'
              - $ref: '#/components/schemas/Like'
              - $ref: '#/components/schemas/Dislike'
              - $ref: '#/components/schemas/Share'
              - $ref: '#/components/schemas/Rate'
              - $ref: '#/components/schemas/Bookmark'
              - $ref: '#/components/schemas/Complete'
              - $ref: '#/components/schemas/Feedback'
              - $ref: '#/components/schemas/Impression'
              - $ref: '#/components/schemas/ViewableImpression'
              - $ref: '#/components/schemas/Click'
              - $ref: '#/components/schemas/HomePageView'
              - $ref: '#/components/schemas/CategoryPageView'
              - $ref: '#/components/schemas/PromoPageView'
              - $ref: '#/components/schemas/ProductImageView'
              - $ref: '#/components/schemas/Custom'
          default: []
        fl:
          title: Fl
          description: >

            List of fields to retrieve. For example, the following request
            retrieves only the `title` field of each product along

            with the `product_id`, which is always returned.


            ```

            {"fl": ["title"]}

            ```


            You can also match field names by using `*` as a wildcard. For
            example, the query below retrieves the `title`

            and any custom attributes under the `attributes` dictionary.


            ```

            {"fl": ["title", "attributes.*"]}

            ```


            The following retrieves all the available fields:


            ```

            {"fl": ["*"]}

            ```


            For the lowest latency, use an empty array to retrieve just the
            `product_id` field (which is the default).

            ```

            {"fl": []}

            ```
          type: array
          items:
            type: string
          default: []
        exclude:
          title: Exclude
          description: >-
            An array of `product_ids` of products you want to *exclude* from
            search results.
          type: array
          items:
            type: string
        boosting_tags:
          title: Boosting Tags
          description: >

            When `boosting_tags` is given, and there are pre-defined boost rules
            have the same tag(s),

            those boost rules will be matched, regardless if the criteria is met
            or not.


            Useful when want to force trigger specific boost campaign.
          type: array
          items:
            type: string
          default: []
          example:
            - tag-1
            - quetag-2
        fq:
          title: Fq
          description: >


            Defines a query in Solr syntax that can be used to restrict the
            superset of

            products to return, without influencing the overall ranking. `fq`
            can enable users to drill down to products

            with specific features based on different product attributes


            For example, the query below limits the search results to only show
            products whose size is either `M` or `S` and

            brand is `Nike`:


            ```

            {"fq": "size:(\"M\" OR \"S\") AND brand:\"Nike\""}

            ```


            You can use `fq` to apply filters against your custom attributes as
            well. For example, the query below limits the

            search results to only products whose `designer` attribute is
            `Calvin Klein`


            ```

            {"fq": "attributes.designer:\"Calvin Klein\""}

            ```


            `fq` can also limit search results by numerical range. For example,
            the following query limits the results to

            products that have `rating >= 4`.


            ```

            {"fq": "rating:[4 TO *]"}

            ```
          type: string
        boost_fq:
          title: Boost Fq
          description: >

            Defines a query in Solr syntax that can be used to boost a subset of
            products to the top of the ranking, or to

            specific *boost positions* (See `boost_positions` parameter below.)

            For example, the query below will promote all the relevant products
            whose brand is `Nike` to the top of

            recommendation list:


            ```

            {
                "boost_fq": "brand:\"Nike\""
            }

            ```


            For a slightly more complex example, the query below will promote
            the Nike products which have also been tagged

            as `ON SALE` to the top of the ranking:

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\""
            }

            ```

            It is worth mentioning that, Miso will only boost products that are
            relevant and have high likelihood to convert,

            and will not boost a low performance product only because it matches
            the boosting query.


            Depending on your boosting rules, in certain cases, you would like
            to prevent recommendation results from being

            too monotone due to boosting. With Miso, you have two tools to do
            so.


            First, you can specify `boost_positions` to place promoted products
            at specific positions in the ranking. For

            example, the query below will place boosted products only at the
            first and fourth places in the ranking

            (positions are 0-based), and place the remaining products in their
            original ranking, skipping these two positions.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "boost_positions": [0, 3]
            }

            ```


            The second tool is `diversification`. `diversification` parameter,
            on a best-effort basis, will try to

            maintain a minimum distance between products that have the same
            attributes. For example, the following query

            will place products made by the same brand apart from each other.

            ```

            {
               "boost_fq": "brand:\"Nike\" AND tags:\"ON SALE\"",
               "diversification": {
                   "brand": {"minimum_distance": 1}
                }
            }

            ```
          type: string
        boost_positions:
          title: Boost Positions
          description: >

            Defines a list of 0-based positions you want to place the boosted
            products at.


            For example, the query below will promote products whose brand is
            `Nike` as the top and second recommendations:

            ```

            {
                "boost_fq": "brand:\"Nike\"",
                "boost_positions": [0, 1]
            }

            ```

            If `boost_positions` is not specified (which is the default
            behavior), all the boosted products will be ranked

            higher than the rest of the products.
          type: array
          items:
            type: integer
        boost_rules:
          title: Boost Rules
          description: >

            Define a list of boosting rules that will be applied to the search
            or recommendation results simultaneously. `boost_rules`

            parameter is particularly useful when you want to boost more than
            one sets of products, and promote each of them to different

            positions. For example, the query below will promote products whose
            brand is `Nike` to the top

            and second results, and products whose brand is `Adidas` to the
            third and fourth results:

            ```

            {
                "boost_rules": [
                    {
                        "boost_fq": "brand:\"Nike\"",
                        "boost_positions": [0, 1]
                    },
                    {
                        "boost_fq": "brand:\"Adidas\"",
                        "boost_positions": [2, 3]
                    }
                ]
            }

            ```
          type: array
          items:
            $ref: '#/components/schemas/BoostingFilterBase'
          default: []
        geo:
          $ref: '#/components/schemas/GeoQuery'
        diversification:
          title: Diversification
          description: >


            Defines diversification rules to prevent products with the same
            attributes (e.g. sneakers made by the same brand

            or books from the same authors) from showing up too close to each
            other in the results.


            For instance, customers who have purchased many of sneakers from
            Nike may happen to have recommendations or

            search results where all top-5 entries are sneakers made by Nike.
            Purely considering accuracy, these

            recommendations appear excellent since the user clearly appreciates
            Nike sneakers. However,

            such results might be considered too "plain" by the user, owing to
            its lack of diversity.


            `diversification` parameter allows you to avoid this problem by
            enforcing a desired *minimum distance* between

            products. For example, consider a list of four products whose
            `brand` are *Nike, Nike, Adidas,* and *PUMA*

            respectively. The query below will make sure there are at least one
            different product between two Nike

            products, e.g. the diversified ranking may become *Nike, Adidas,
            Nike,* and *PUMA* :

            ```

            {
               "diversification": {"brand": {"minimum_distance": 1}}
            }

            ```


            You can also increase the minimum_distance to place products further
            apart. For example, the following query will

            make sure, for the two Nike products, there are at least *two* other
            products between them.

            As a result, the diversified ranking may become *Nike, Adidas,
            PUMA*, and *Nike*.:

            ```

            {
               "diversification": {"brand": {"minimum_distance": 2}}
            }

            ```


            The diversification algorithm reranks the products on a best-effort
            basis. For example, for the product list

            described earlier, it is not possible to place two Nike product
            three places apart from each other. Therefore,

            the diversified ranking will still remain *Nike, Adidas, PUMA,* and
            Nike* even if we set `minimum_distance=3`.
          type: object
          additionalProperties:
            $ref: '#/components/schemas/DiversifyField'
        pagination_id:
          title: Pagination Id
          description: >

            A unique identifier to enable pagination in Recommendation APIs. By
            default, Recommendation APIs do not support

            pagination because the results from Miso, by its natural, will
            change in real-time with new user interactions.

            `pagination_id` allows you to implement pagination more easily by
            memorize what products we have

            returned to the current user with the same `pagination_id`.


            To enable pagination, you generate a `pagination_id` and set it in
            the first and subsequent requests in the same browsing session

            where you want to enable pagination. With `pagination_id` set, you
            can access recommendations

            in different pages using the combination of `start` and `rows`
            parameters, and Miso will ensure that no duplicated

            recommendation will be returned in different pages.


            For example, assuming you are implementing an infinite scroll with
            Miso Recommendation APIs. Before you make the first request,

            you generate a `pagination_id` using the `current datetime` or
            `uuid` like the following:

            ```javascript

            // current datetime

            var my_pagination_id = Date.now().toString()

            // OR uuid

            const uuidv4 = require("uuid/v4")

            var my_pagination_id = uuidv4()

            ```

            You can then request the first page of results with
            `my_pagination_id` like the following:

            ```javascript

            {
                "pagination_id": my_pagination_id,
                "start": 0,
                "rows": 10
            }

            ```

            Then, you can request the next page of results with the same
            `my_pagination_id`, and Miso will ensure

            that no duplicated result is returned:

            ```javascript

            {
                "pagination_id": my_pagination_id,
                "start": 10,
                "rows": 10
            }

            ```


            Note that, a `pagination_id` will timeout if there is no further
            request associated with it for 30 minutes.

            Also, `pagination_id` is scoped by individual users: i.e. different
            users' results will not be affected

            even if they use the same `pagination_id`.
          maxLength: 512
          type: string
        start:
          title: Start
          description: >

            The start of the page you want to access. Combine this with `rows`
            to implement pagination. You can only set it when `pagination_id` is
            given.
          type: integer
          default: 0
      x-konfig-properties:
        geo:
          title: Geo
          description: >

            When set, filter result to include only products within certain
            geographic range from given point will be returned,

            or to boost product within the same range.


            Product should have a field that holds the location of the product,
            `location` is used by default,

            but other field can also be used.


            Distance can be in miles or kilometers. If `distance_unit` is not
            set, `mile` will be used.


            For example, to limit results to products within 100 miles of New
            York city:

            ```

            {
                "geo": {
                    "filter": [{
                        "lat": 40.73061,
                        "lon": -73.93524,
                        "distance": 100
                    }]
                }
            }

            ```


            To boost products within 2 kilometers around Alcatraz Island
            according to `loc` field:

            ```

            {
                "geo": {
                    "boost": [{
                        "field": "loc",
                        "lat": 37.82667,
                        "lon": -122.42278,
                        "distance": 2,
                        "distance_unit": "km"
                    }]
                }
            }

            ```
    app__schemas__engine_api__request__PreviewBoosting:
      title: PreviewBoosting
      description: Properties to receive on Boosting creation
      required:
        - query_option
        - boost_match_type
        - boost
        - position
      type: object
      properties:
        query:
          title: Query
          description: The boosting rule query.
          type: string
        queries:
          title: Queries
          description: Multiple query of the boosting rule.
          type: array
          items:
            type: string
        query_option:
          title: Query Option
          description: >-
            The options of the query. Please fill this field with contains,
            not_contain, is, and is_not value.
          enum:
            - contains
            - not_contain
            - is
            - is_not
          type: string
        filter_query:
          title: Filter Query
          description: The filter queries of the boosting rule.
          type: array
          items:
            $ref: '#/components/schemas/FilterQueryItem'
        boost_match_type:
          title: Boost Match Type
          description: Type of the query. Please fill this field with any or all.
          enum:
            - any
            - all
          type: string
        boost:
          title: Boost
          description: The items of the boosting rule.
          type: array
          items:
            $ref: '#/components/schemas/BoostItem'
        position:
          title: Position
          description: The position of the boosting rule should occur.
          type: array
          items:
            type: integer
        json_asset:
          title: Json Asset
          description: The boosting json asset.
          type: string
          example:
            CO:
              - product-name: name
                product-image-url: url
        boosting_tags:
          title: Boosting Tags
          description: The comma-separated boosting tags.
          type: array
          items:
            type: string
          example:
            - tag-1
            - tag-2
    app__schemas__engine_api__request__Question:
      title: Question
      description: Question object
      required:
        - question
      type: object
      properties:
        question:
          title: Question
          description: The text of question.
          minLength: 1
          type: string
        weight:
          title: Weight
          description: The weight of question.
          type: number
          default: 1
    app__schemas__engine_api__response__Question:
      title: Question
      description: 'Question object '
      required:
        - question
      type: object
      properties:
        question:
          title: Question
          minLength: 1
          type: string
        weight:
          title: Weight
          type: number
          default: 1
    app__schemas__rec_boosting__PreviewBoosting:
      title: PreviewBoosting
      description: Attributes of boosting
      required:
        - api_names
        - boost_match_type
        - boost
        - position
      type: object
      properties:
        api_names:
          title: Api Names
          description: The api_names values
          type: array
          items:
            type: string
        anchor_products:
          title: Anchor Products
          description: The anchor products ids
          type: array
          items:
            type: string
          default: []
        module_names:
          title: Module Names
          description: The module name
          type: array
          items:
            type: string
        boost_match_type:
          title: Boost Match Type
          description: Type of the query. Please fill this field with any or all.
          enum:
            - any
            - all
          type: string
        boost:
          title: Boost
          description: The items of the boosting rule.
          type: array
          items:
            $ref: '#/components/schemas/BoostItem'
        position:
          title: Position
          description: 1-based index of the position of the boosting rule should occur.
          type: array
          items:
            type: integer
          example:
            - 1
            - 2
        boosting_tags:
          title: Boosting Tags
          description: The comma-separated boosting tags.
          type: array
          items:
            type: string
          example:
            - tag-1
            - tag-2
    ExperimentApIsSendEventResponse:
      type: object
      properties:
        message:
          type: string
          example: api_key is invalid. Please check your api_key in Dojo.
      example:
        message: api_key is invalid. Please check your api_key in Dojo.
    ExperimentApIsSendEvent404Response:
      type: object
      properties:
        message:
          type: string
          example: Variant is not found. Please check your variant_name.
      example:
        message: Variant is not found. Please check your variant_name.
    ExperimentApIsSendEvent422Response:
      type: object
      properties:
        message:
          type: string
          example: Request schema error. See "data.errors" for details
        data:
          type: object
          properties:
            errors:
              type: array
              items:
                type: object
                properties:
                  loc:
                    type: array
                    items:
                      oneOf:
                        - type: string
                          example: body
                        - type: number
                          example: 35
                      example: 35
                  msg:
                    type: string
                    example: 'Expecting '','' delimiter: line 3 column 5 (char 35)'
                  type:
                    type: string
                    example: value_error.jsondecode
      example:
        message: Request schema error. See "data.errors" for details
        data:
          errors:
            - loc:
                - body
                - 35
              msg: 'Expecting '','' delimiter: line 3 column 5 (char 35)'
              type: value_error.jsondecode
    InteractionApIsInsertRecordsResponse:
      type: object
      properties:
        message:
          type: string
          example: invalid api key.
      example:
        message: invalid api key.
    InteractionApIsInsertRecords403Response:
      type: object
      properties:
        message:
          type: string
          example: >-
            Request is denied due to bot blocking. Please only access this API
            from a real browser or use Secret API Key instead.
      example:
        message: >-
          Request is denied due to bot blocking. Please only access this API
          from a real browser or use Secret API Key instead.
    InteractionApIsInsertRecords422Response:
      type: object
      properties:
        errors:
          type: boolean
          example: true
        message:
          type: string
          example: >-
            None of the records were inserted because at least one of them
            contained schema errors. Please see the `data` field for details.
        data:
          type: array
          items:
            type: string
            example: >-
              data.0.product_ids is invalid. The attribute was expected to be of
              type ''array', 'null'' but type 'string' was given.
      example:
        errors: true
        message: >-
          None of the records were inserted because at least one of them
          contained schema errors. Please see the `data` field for details.
        data:
          - >-
            data.0.product_ids is invalid. The attribute was expected to be of
            type ''array', 'null'' but type 'string' was given.
          - >-
            data.0.timestamp is invalid. The attribute should match the
            'date-time' format.
    ProductContentApIsBulkInsertResponse:
      type: object
      properties:
        'message:':
          type: string
          example: Request timeout.
      example:
        'message:': Request timeout.
    ProductContentApIsBulkInsert401Response:
      type: object
      properties:
        message:
          type: string
          example: invalid api key.
      example:
        message: invalid api key.
    ProductContentApIsBulkInsert403Response:
      type: object
      properties:
        message:
          type: string
          example: >-
            Request is denied due to bot blocking. Please only access this API
            from a real browser or use Secret API Key instead.
      example:
        message: >-
          Request is denied due to bot blocking. Please only access this API
          from a real browser or use Secret API Key instead.
    ProductContentApIsBulkInsert422Response:
      type: object
      properties:
        errors:
          type: boolean
          example: true
        message:
          type: string
          example: >-
            None of the records are inserted, because at least one of them
            contain schema errors. Please see `data` field for details.
        data:
          type: array
          items:
            type: string
            example: >-
              data.0.product_id is invalid. The attribute expected to be of type
              'string', but 'array' is given.
      example:
        errors: true
        message: >-
          None of the records are inserted, because at least one of them contain
          schema errors. Please see `data` field for details.
        data:
          - >-
            data.0.product_id is invalid. The attribute expected to be of type
            'string', but 'array' is given.
          - >-
            data.0.created_at is invalid. The attribute should match 'date-time'
            format.
    ProductContentApIsBulkInsert500Response:
      type: object
      properties:
        message:
          type: string
          example: Something went wrong. Please contact miso product team.
      example:
        message: Something went wrong. Please contact miso product team.
    ProductContentApIsDeleteProductContentResponse:
      type: object
      properties:
        'message:':
          type: string
          example: Request timeout.
      example:
        'message:': Request timeout.
    ProductContentApIsDeleteProductContent401Response:
      type: object
      properties:
        message:
          type: string
          example: invalid api key.
      example:
        message: invalid api key.
    ProductContentApIsDeleteProductContent403Response:
      type: object
      properties:
        message:
          type: string
          example: >-
            Request is denied due to bot blocking. Please only access this API
            from a real browser or use Secret API Key instead.
      example:
        message: >-
          Request is denied due to bot blocking. Please only access this API
          from a real browser or use Secret API Key instead.
    ProductContentApIsDeleteProductContent500Response:
      type: object
      properties:
        message:
          type: string
          example: Something went wrong. Please contact miso product team.
      example:
        message: Something went wrong. Please contact miso product team.
    ProductContentApIsGetProductDetailsResponse:
      type: object
      properties:
        message:
          type: string
          example: invalid api key.
      example:
        message: invalid api key.
    ProductContentApIsGetProductDetails404Response:
      type: object
      properties:
        message:
          type: string
          example: not found
      example:
        message: not found
    ProductContentApIsGetProductDetails500Response:
      type: object
      properties:
        message:
          type: string
          example: Something went wrong. Please contact miso product team.
      example:
        message: Something went wrong. Please contact miso product team.
    ProductContentApIsGetProductIdsResponse:
      type: object
      properties:
        message:
          type: string
          example: invalid api key.
      example:
        message: invalid api key.
    ProductContentApIsGetProductIds500Response:
      type: object
      properties:
        message:
          type: string
          example: Something went wrong. Please contact miso product team.
      example:
        message: Something went wrong. Please contact miso product team.
    ProductContentApIsBulkDeleteResponse:
      type: object
      properties:
        'message:':
          type: string
          example: Request timeout.
      example:
        'message:': Request timeout.
    ProductContentApIsBulkDelete401Response:
      type: object
      properties:
        message:
          type: string
          example: invalid api key.
      example:
        message: invalid api key.
    ProductContentApIsBulkDelete403Response:
      type: object
      properties:
        message:
          type: string
          example: >-
            Request is denied due to bot blocking. Please only access this API
            from a real browser or use Secret API Key instead.
      example:
        message: >-
          Request is denied due to bot blocking. Please only access this API
          from a real browser or use Secret API Key instead.
    ProductContentApIsBulkDelete500Response:
      type: object
      properties:
        message:
          type: string
          example: Something went wrong. Please contact miso product team.
      example:
        message: Something went wrong. Please contact miso product team.
    UserApIsBulkUploadResponse:
      type: object
      properties:
        'message:':
          type: string
          example: Request timeout.
      example:
        'message:': Request timeout.
    UserApIsBulkUpload401Response:
      type: object
      properties:
        message:
          type: string
          example: invalid api key.
      example:
        message: invalid api key.
    UserApIsBulkUpload403Response:
      type: object
      properties:
        message:
          type: string
          example: >-
            Request is denied due to bot blocking. Please only access this API
            from a real browser or use Secret API Key instead.
      example:
        message: >-
          Request is denied due to bot blocking. Please only access this API
          from a real browser or use Secret API Key instead.
    UserApIsBulkUpload422Response:
      type: object
      properties:
        errors:
          type: boolean
          example: true
        message:
          type: string
          example: >-
            None of the records are inserted, because at least one of them
            contain schema errors. Please see `data` field for details.
        data:
          type: array
          items:
            type: string
            example: >-
              data.0.user_id is invalid. The attribute expected to be of type
              'string', but 'array' is given.
      example:
        errors: true
        message: >-
          None of the records are inserted, because at least one of them contain
          schema errors. Please see `data` field for details.
        data:
          - >-
            data.0.user_id is invalid. The attribute expected to be of type
            'string', but 'array' is given.
          - >-
            data.0.created_at is invalid. The attribute should match 'date-time'
            format.
    UserApIsBulkUpload500Response:
      type: object
      properties:
        message:
          type: string
          example: Something went wrong. Please contact miso product team.
      example:
        message: Something went wrong. Please contact miso product team.
    UserApIsDeleteUserResponse:
      type: object
      properties:
        'message:':
          type: string
          example: Request timeout.
      example:
        'message:': Request timeout.
    UserApIsDeleteUser401Response:
      type: object
      properties:
        message:
          type: string
          example: invalid api key.
      example:
        message: invalid api key.
    UserApIsDeleteUser403Response:
      type: object
      properties:
        message:
          type: string
          example: >-
            Request is denied due to bot blocking. Please only access this API
            from a real browser or use Secret API Key instead.
      example:
        message: >-
          Request is denied due to bot blocking. Please only access this API
          from a real browser or use Secret API Key instead.
    UserApIsDeleteUser500Response:
      type: object
      properties:
        message:
          type: string
          example: Something went wrong. Please contact miso product team.
      example:
        message: Something went wrong. Please contact miso product team.
    UserApIsGetUserDetailsResponse:
      type: object
      properties:
        message:
          type: string
          example: invalid api key.
      example:
        message: invalid api key.
    UserApIsGetUserDetails403Response:
      type: object
      properties:
        message:
          type: string
          example: >-
            Request is denied due to bot blocking. Please only access this API
            from a real browser or use Secret API Key instead.
      example:
        message: >-
          Request is denied due to bot blocking. Please only access this API
          from a real browser or use Secret API Key instead.
    UserApIsGetUserDetails404Response:
      type: object
      properties:
        message:
          type: string
          example: not found
      example:
        message: not found
    UserApIsGetUserDetails500Response:
      type: object
      properties:
        message:
          type: string
          example: Something went wrong. Please contact miso product team.
      example:
        message: Something went wrong. Please contact miso product team.
    UserApIsBulkUserDeleteResponse:
      type: object
      properties:
        'message:':
          type: string
          example: Request timeout.
      example:
        'message:': Request timeout.
    UserApIsBulkUserDelete401Response:
      type: object
      properties:
        message:
          type: string
          example: invalid api key.
      example:
        message: invalid api key.
    UserApIsBulkUserDelete403Response:
      type: object
      properties:
        message:
          type: string
          example: >-
            Request is denied due to bot blocking. Please only access this API
            from a real browser or use Secret API Key instead.
      example:
        message: >-
          Request is denied due to bot blocking. Please only access this API
          from a real browser or use Secret API Key instead.
    UserApIsBulkUserDelete500Response:
      type: object
      properties:
        message:
          type: string
          example: Something went wrong. Please contact miso product team.
      example:
        message: Something went wrong. Please contact miso product team.
  securitySchemes:
    Secret API Key:
      description: >+

        Your secret API key is used to access every Miso API endpoint. You
        should secure this key and only use it on a backend 

        server. Never leave this key in your client-side JavaScript code. If the
        private key is compromised, you can revoke it 

        in [Dojo](https://dojo.askmiso.com/docs/api-browser) and get a new one.


        Specify your secret key in the `api_key` query parameter. For example:

        ```

        POST /v1/users?api_key=039c501ac8dfcac91c6f05601cee876e1cc07e17

        ```

      type: apiKey
      in: query
      name: api_key
    Publishable API Key:
      description: >

        Your publishable API key is used to call Miso's APIs from your front-end
        code. It can be used to stream interactions from the browser using
        Miso's Interactions Upload API or to access read-only search and
        recommendation results for a given user. When using the publishable API
        key, the requested user_id will need to be hashed to maintain the
        necessary security compliance. 


        Specify your publishable key in the `api_key` query parameter. For
        example:

        ```

        POST /v1/interactions?api_key=039c501ac8dfcac91c6f05601cee876e1cc07e17

        ```
      type: apiKey
      in: query
      name: api_key
x-tagGroups:
  - tags:
      - Interaction APIs
      - Product / Content APIs
      - User APIs
    name: Data APIs
  - tags:
      - Search APIs
      - Recommendation APIs
      - Ask APIs
      - Signal API
      - Bulk API
    name: Engine APIs
  - tags:
      - Experiment APIs
    name: Experiment APIs
  - tags:
      - Q&A APIs
    name: Q&A API
